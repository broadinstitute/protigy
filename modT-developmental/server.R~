################################################################################################################
## Filename: server.r
## Created: October 09, 2015
## Author(s): Karsten Krug
##
## Purpose: Shiny-app to perform differential expression analysis, primarily on proteomics data, to perform
##          simple data QC, to interactively browse through the results and to download high-quality result
##          figures.
##
## This file defines the server logical of the app. It also takes care of most of the user interface.
##
################################################################################################################
library(shiny)

############################################
## set maximum file size for upload
############################################
options(shiny.maxRequestSize = MAXSIZEMB*1024^2)


###########################################################################################################
##                         Define server logic
############################################################################################
shinyServer(

    function(input, output, session) {

        #####################################
        ## reactive variables to store
        ## data accross a session
        #####################################

        ## error messages
        error <- reactiveValues()

        ## test results
        global.results <-  reactiveValues(
            data=NULL,
            table.norm=NULL,
            export.results=F,
            table.repro.filt=NULL,
            pca=NULL,
            table.log=NULL,
            repro.filt=NULL
        )
        ## input data
        global.input <- reactiveValues()

        ##################################################
        ## parameters
        global.param <-  reactiveValues(
            session=NULL,                ## session id
            user=NULL,                   ## user
            grp=NULL,                    ## the actual group assignment
            N.grp=NULL,                  ## number of defined groups
            grp.colors=NULL,             ## group color assignment
            grp.colors.legend=NULL,      ## group colors, names are group names
            grp.done=F,                  ## group assignment finished?
            which.test='One-sample mod T', ## specify test
            log.transform='none',        ## log transformation
            norm.data='none',            ## data normalization
            repro.filt='no',              ## reproducibility filter
            session.imported=F,          ## flag whether this is an imported session
            session.import.init=F,              ## flag for initiate the session (used for to switch between default values for 'filter.value' and user=sepcified, i.e. after importing a session)
            analysis.run=F,              ## flag whether the analysis has been run

            filter.type='adj.p',         ## default filter
            filter.value=0.05            ## default filter value

        )

        #####################################################
        ## plotting params
        plotparams <- reactiveValues(

            ## multiscatter
            ms.max=FALSE,
            ms.min.val=-4,
            ms.max.val=4,

            ## volcano
            volc.ps=2,    ## point size
            volc.ls=1,    ## label size
            volc.grid=T,  ## grid
            volc.maxp=100,## max. -log10 p-value

            ## heatmap
            hm.cexCol=12,
            hm.cexRow=8,
            hm.scale="none",
            hm.max=FALSE,
            hm.max.val=4,

            ## PCA
            pca.x='PC 1',
            pca.y='PC 2',
            pca.z='PC 3',

            ## correlation matrix
            cm.upper='pearson',
            cm.lower='spearman',
            cm.numb=TRUE
        )

        ## coordinates in volcano plot
        volc <- reactiveValues()

        ##@##############################################################################
        ##
        ##                                instructions / help pages
        ##
        ##@##############################################################################
        callModule(printHTML, id='getting.started', what='gs', global.input = global.input)
        callModule(printHTML, id='change.log', what='cl', global.input = global.input)
        callModule(printHTML, id='id.column', what='id', global.param=global.param, global.input=global.input)
        callModule(printHTML, id='exp.design', what='ed', global.param=global.param, global.input=global.input)
        callModule(printHTML, id='analysis', what='ana', global.param=global.param, global.input=global.input)
        ##callModule(printHTML, id='results', what='res', global.param=global.param, global.input=global.input)

        #################################
        ## F5 hint
        output$F5hint <- renderText({

            HTML('<p align=\"center\"><font size=\"5\" color=\"red\">To analyze another data set or to start over hit the F5 button.</font></p>' )

        })

        #####################################
        ## Error messages
        output$error <- renderText({
            if( is.null(error$msg) ) return()
            HTML(paste('<p align=\"center\"><font size=\"5\" color=\"red\">', error$msg,'</font></p>'))
        })

        ################################################################################
        ##
        ##                                navigation bar
        ##
        ################################################################################
        output$navbar <- renderUI({

            if(!global.param$analysis.run) return()

            ##############################################
            ## determine the number of group comparisons,
            ## e.g. for the number of volcano plots to draw
            ##############################################
            groups.comp <- unique(global.param$grp.comp)

            ################################################################################################################
            ##
            ##                           define the different tabs shown in the navigation bar
            ##
            ################################################################################################################

            ## ############################################################
            ##
            ## tab to manage exported sessions
            ##
            ## ############################################################
            
            # manage.sessions.tab <- tabPanel('Manage sessions',{
            # 
            #     fluidPage(
            #         fluidRow(
            # 
            #         )
            #     )
            # 
            # }
            # )

            ###############################################################
            ## EXPORT tab
            ## - export all figures/tables at once and generate a zip file
            ## - download the zip file
            ###############################################################
            export.tab <- tabPanel('Export',
                                   if(!(global.results$export.results)){
                                      fluidPage(
                                      fluidRow(
  
                                         column(width=6,
                                         box(title="Session name:",
                                              textInput( 'label', '', value=global.param$label, width=200), 
                                              status = "primary",
                                             solidHeader = T,
                                             width=NULL
                                             )
                                         ),
                                         column(width=6,
                                         box(title="Specify what to export:",
                                             checkboxInput('export.hm', 'Heatmap',value=T),
                                             checkboxInput('export.box', 'Boxplots',value=T),
                                             checkboxInput('export.volc', 'Volcano plot',value=T),
                                             checkboxInput('export.phist', 'P-value histogram',value=T),
                                             checkboxInput('export.pca', 'PCA',value=T),
                                             checkboxInput('export.ms', 'Multiscatter',value=T),
                                             checkboxInput('export.excel', 'Excel sheet',value=T),
                                             checkboxInput('export.cm', 'Correlation matrix',value=T),
                                             checkboxInput('export.profile', 'Profile plot',value=T), 
                                             
                                             status = "primary",
                                             solidHeader = T,
                                             width=NULL
                                             
                                             )
                                         )
                                       ), 
                                     fluidRow(column(width=6,
                                         
                                         box(title="Export results", actionButton('export.results', 'Export (.zip)'), 
                                             status = "primary",
                                             solidHeader = T,
                                             width=NULL)
                                           ##fluidRow(box(column(3, h4('Export results:')), column(3, actionButton('export.results', 'Export (.zip)')), column(6)))
                                       ))
                                   )
                                     
                                   } else {
                                       fluidPage(
                                           fluidRow( column(3, h4('Choose a label:')), column(6, textInput( 'label', '',value=global.param$label, width=200)), column(3)),
                                           fluidRow(column(3, h4('Specify what to export:')), column(9)),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.hm', 'Heatmap',value=T)), column(3, checkboxInput('export.box', 'Boxplots',value=T)), column(3)
                                           ),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.volc', 'Volcano plot',value=T)), column(3, checkboxInput('export.phist', 'P-value histogram',value=T)), column(3)
                                           ),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.pca', 'PCA',value=T) ), column(3, checkboxInput('export.ms', 'Multiscatter',value=T)), column(3)
                                           ),
                                           fluidRow(column(3), column(3, checkboxInput('export.excel', 'Excel sheet',value=T)), column(3, checkboxInput('export.cm', 'Correlation matrix',value=T)), column(3)),
                                           tags$br(),
                                           tags$hr(),
                                           tags$br(),
                                           fluidRow(column(3, h4('Export results:')), column(3, actionButton('export.results', 'Export (.zip)')), column(6)),
                                           tags$br(),
                                           tags$br(),
                                           fluidRow(column(3, h4('Download results:')), column(3, downloadButton('download.results', 'Download (.zip)')), column(6)),
                                           tags$br()
                                       )

                                   }
                                   )

            ############################################
            ## SUMMARY
            ##    some general numbers on the
            ##    uploaded data
            ##
            ############################################
            summary.tab <-  tabPanel('Summary',
                                   
                                        fluidRow(
                                        box(title="Dataset:", solidHeader = T, status = "primary", width = 4,
                                          tableOutput('summary.data')),
                                      
                                        box(title="Workflow:", solidHeader = T, status = "primary",width = 4,
                                          tableOutput('summary.workflow')),
                                      
                                        box(title="Test results:", solidHeader = T, status = "primary",width = 4,
                                          tableOutput('summary.test'))
                                      ),
                                    fluidRow(
                                      box(title="Non-missing values:", solidHeader = T, status = "primary",width = 12,
                                          plotlyOutput('summary.nonmissing.data'))
                                    ), 
                                    fluidRow(
                                     box(title="Non-missing values:", solidHeader = T, status = "primary",width = 12,    
                                          plotlyOutput('summary.missing.data.row'))
                                    )
                          ) ## end tab panel
                                

            ############################################
            ## VOLCANO
            ##      tabs for the volcano plots
            ## NOT for F test
            ############################################
           ## if(global.param$which.test != 'mod F'){
                volc.tabs <- list()
                volc.tabs[[1]] <- 'Volcanos'
                for(i in 1:length(unique(groups.comp))){
                    volc.tabs[[i+1]]=tabPanel(paste0( groups.comp[i] ),

                                          fluidPage(
                                            fluidRow(
                                            box( title='', status = 'primary', solidHeader = F, width=12,
                                            fluidRow(
                                             
                                                   
                                                  column(3, numericInput( paste("cex.volcano",groups.comp[i], sep='.'), "Point size", value=plotparams$volc.ps, min=1, step=1)),
                                                  ##column(1, numericInput( paste("opac.volcano",groups.comp[i],sep='.'), "Opacity %", value=50, min=0, max=100, step=10)),
                                                  column(3, numericInput( paste("cex.volcano.lab",groups.comp[i],sep='.'), "Label size", value=plotparams$volc.ls, min=.1, step=.1)),
                                                  column(3, selectInput( paste("grid.volcano",groups.comp[i],sep='.'), "Grid", c(T, F), selected=plotparams$volc.grid)),
                                                  column(3, numericInput("max.logP", "Max. Log10(P-value)", value=plotparams$volc.maxp, min=20, max=100, step=10) )
                                                  
                                                  ##column(1, downloadButton(paste('downloadVolcano', groups.comp[i],sep='.'), 'Download (pdf)'))
                                              ))),
                                            fluidRow(
                                            
                                              column(width=8, box( width=NULL,  title='Volcano plot', status = 'primary', solidHeader = T,
                                                 ##plotOutput( paste("volcano",groups.comp[i], sep='.'), width=600, height=600, click=paste('plot_click', groups.comp[i], sep='.'), hover=hoverOpts(id=paste('plot_hover', groups.comp[i], sep='.'), delay=10) )
                                                 plotOutput( paste("volcano",groups.comp[i], sep='.'), height=600, click=paste('plot_click', groups.comp[i], sep='.'), hover=hoverOpts(id=paste('plot_hover', groups.comp[i], sep='.'), delay=10) )
                                                 
                                                 )),
                                              column(width=4, box(width=NULL,  title='Click a point', status = 'primary', solidHeader = T,
                                                     tableOutput(paste('volc.tab.selected', groups.comp[i], sep='.'))
                                              )))
                                          )
                                        
                                        ) ## end tabPanel
                } ## end for i
           ## } ## end if not mod F

            ############################################
            ## HEATMAP
            ##
            ############################################
            hm.tab <-  tabPanel('Heatmap',
                                    fluidPage(
                                      fluidRow(
                                        ##box(title='Select Principle Components', status = 'primary', solidHeader = T,
                                            column(2, h4('Column labels')),
                                            column(2, h4('Row labels')),
                                            column(8)
                                            ##column(9),
                                            ##column(1, h4('Export'))
                                          ##)
                                        ),
                                        fluidRow(
                                            column(2, numericInput( "cexCol", "Size", value=12, min=1, step=1)),
                                            column(2, numericInput( "cexRow", "Size", value=8, min=1, step=1)),
                                            column(2, selectInput( "hm.scale", "Scale", c("row","column","none"), selected=plotparams$hm.scale)),
                                            column(2, selectInput( "hm.clust", "Cluster", c("column","row","both","none"), selected=ifelse(global.param$which.test != "mod F", "none" ,"both"))),
                                            ##column(2),
                                            column(1, checkboxInput('hm.max', 'Cap values', value=plotparams$hm.max)),
                                            column(2, numericInput( "hm.max.val", "Max. value", value=plotparams$hm.max.val, step=1, min=2)),
                                            column(1)
                                        ),
                                        tags$br(),
                                        tags$hr(),
                                        tags$br(),
                                        fluidRow(
                                            column(12, align='center', plotOutput("HM") )
                                        ),
                                        tags$br(),
                                        tags$hr(),
                                        tags$br()
                                    )
                                )

            #############################################
            ## PCA
            ##
            #############################################
            ##pca.tab <- vector('list', 3)
            # pca.tab <- tabPanel('PCA', 
            #                     fluidPage(
            #                       
            #                            ## 2D
            #                       fluidRow(
            #                         column(12, align='center',
            #                         box( title='Select Principle Components', status = 'primary', solidHeader = T,
            #                           fluidRow(
            #                             column(4,selectInput('pca.x', 'x-axis', paste('PC', 1:10), selected=plotparams$pca.x)),  
            #                             column(4,selectInput('pca.y', 'y-axis', paste('PC', 1:10), selected=plotparams$pca.y)),  
            #                             column(4,selectInput('pca.z', 'z-axis', paste('PC', 1:10), selected=plotparams$pca.z))
            #                           )
            #                         
            #                         )
            #                       )),
            #                       fluidRow(
            #                         box( title='2D', status = 'primary', solidHeader = T, width = 1000, height = 700,
            #                           column(12, align='center', plotlyOutput("pcaxy.plotly", width=600, height=600))
            #                         )
            #                       ), ##tags$hr(),
            #                       fluidRow(
            #                         box( title='3D', status = 'primary', solidHeader = T, width = 800, height = 900,     
            #                            column(12, align='center', plotlyOutput("pcaxyz.plotly", width=800, height=800))
            #                         )
            #                       ),
            #                       fluidRow(
            #                         box(title='Figure to download', status = 'primary', solidHeader = T, width = 1200, height = 400,
            #                          column(12, align='center', plotOutput("pca", width=900, height=300)) 
            #                         )
            #                       )
            #                     )
            #                     
            #                     
            # )
            # 
            pca.tab2 <- vector('list', 3)
            pca.tab2[[1]] <- tabPanel('Run PCA',
                    fluidRow(
          
                      
                      box(title='Summary', status='primary', solidHeader = T, htmlOutput('run.pca')),
                      
                      box(title='Variance', status='primary', solidHeader = T, plotOutput('pca.var'))
                    )                    
            )
            
            pca.tab2[[2]] <- tabPanel('PC plots',
                                      fluidPage(
                                
                                          fluidRow(
                                            box( title = 'Select principle components', status='primary', solidHeader = T, align='center', 
                                              ##column(3),
                                              column(4, selectInput('pca.x', 'x-axis', paste('PC', 1:10)), selected=plotparams$pca.x),
                                              column(4, selectInput('pca.y', 'y-axis', paste('PC', 1:10), selected=plotparams$pca.y)), 
                                              column(4, selectInput('pca.z', 'z-axis', paste('PC', 1:10), selected=plotparams$pca.z))
                                              ##column(3)
                                            )
                                          ),
                                          fluidRow(
                                            box( title='2D', status = 'primary', solidHeader = T, width = 1000, height = 700,
                                                 column(12, align='center', plotlyOutput("pcaxy.plotly", width=600, height=600))
                                            )
                                          ), ##tags$hr(),
                                          fluidRow(
                                            box( title='3D', status = 'primary', solidHeader = T, width = 800, height = 900,     
                                                 column(12, align='center', plotlyOutput("pcaxyz.plotly", width=800, height=800))
                                            )
                                          ),
                                          fluidRow(
                                            box(title='Figure to download', status = 'primary', solidHeader = T, width = 1200, height = 400,
                                                column(12, align='center', plotOutput("pca", width=900, height=300)) 
                                            )
                                          )
                                          

                                      )
            )
            pca.tab2[[3]] <- tabPanel('Loadings',
                                      fluidPage(
                                        
                                        fluidRow(
                                          
                                          box(title='Loadings',
                                              plotlyOutput("pca.loadings")
                                                           )
                                          
                                        )
                                      )
            )
            
            
            #############################
            ## plotly
            # pca.tab[[1]] <- tabPanel('Interactive',
            #                       fluidPage(
            #                         #############################################
            #                         ## 2D
            #                         fluidRow(column(2, selectInput('pca.x', 'x-axis', paste('PC', 1:10)), selected=plotparams$pca.x), column(2, selectInput('pca.y', 'y-axis', paste('PC', 1:10), selected=plotparams$pca.y)), column(2, selectInput('pca.z', 'z-axis', paste('PC', 1:10), selected=plotparams$pca.z)), column(6) ),
            #                         fluidRow(column(12, align='center', plotlyOutput("pcaxy.plotly", width=600, height=600))),
            #                         tags$hr(),
            #                         #############################################
            #                         ## 3D
            #                         fluidRow(column(12, align='center', plotlyOutput("pcaxyz.plotly", width=800, height=800)) ),
            #                         tags$br()
            #                        )
            #                     )
            # 
            # #######################################
            # ## static
            # pca.tab[[2]] <- tabPanel('Static',
            #                          fluidPage(
            #                            
            #                            ##############################################
            #                            ## static figure
            #                            fluidRow( column(12, h3('Static figure:'))),
            #                            fluidRow( column(12, align='center', plotOutput("pca", width=1200, height=400) ) )
            #                            
            #                            ##tags$br(),
            #                            ##tags$hr()
            #                          )
            # )
            # 

            #############################################
            ## TABLE
            ##
            #############################################
            table.tab <- tabPanel('Table',
                     fluidPage(
                         fluidRow(column(12, tags$h3('Result table (filtered):'))),
                         fluidRow(column(12, tags$br())),
                         fluidRow(column(12, dataTableOutput("tableprev")))
                     )
                     )
            #############################################
            ## QC
            ##
            #############################################
            qc.tabs <- vector('list', 5)
            ##names(qc.tabs) <- c('Boxplots', 'P-values', 'Multi scatter', 'Correlation matrix', 'Correlation matrix transposed')

            ###########################
            ## boxplots
            ##qc.tabs[['Boxplots']] <- tabPanel('Boxplots',
            qc.tabs[[1]] <- tabPanel('Boxplots',
                                              fluidPage(
                                                  fluidRow( column(12, plotOutput("expr.boxplot", width=1200, height=max( 30*(ncol( global.input$table)+2), 500)))),
                                                  tags$br(),tags$hr(),tags$br(),
                                                  if(!is.null(global.results$table.norm)) fluidRow(column(12, plotOutput("expr.boxplot.norm", width=1200, height=max( 30*(ncol( global.input$table)+2), 500)))),
                                                  tags$br()
                                              )
                                              )
            ###########################
            ## profile plots
            ##qc.tabs[['Profile plots']] <- tabPanel('Profile plots',
            qc.tabs[[2]] <- tabPanel('Profile plots',

                                                       if(is.null(global.results$table.norm)){
                                                           fluidPage(
                                                               tags$br(),
                                                                fluidRow( column(12, plotOutput("expr.profile", width=600, height=600)))
                                                            )
                                                       } else {
                                                           fluidPage(
                                                               tags$br(),
                                                               fluidRow(
                                                                   column(6, plotOutput("expr.profile", width=600, height=600)),
                                                                   column(6, plotOutput("expr.profile.norm", width=600, height=600))
                                                               )
                                                           )
                                                       }
                                                   )

            ###########################
            ## P-value distribution
            ##qc.tabs[['P-values']] <- tabPanel('P-values',
            qc.tabs[[3]] <- tabPanel('P-values',
                                              fluidPage(
                                                  fluidRow(
                                                      column(12, plotOutput("pval.hist"))
                                                  )
                                              )
                                              )
            ############################
            ## correlation multiscatter
            ##qc.tabs[['Multi scatter']] <- tabPanel('Multi scatter',
            qc.tabs[[4]] <- tabPanel('Multi scatter',
                                                   fluidPage(
                                                       fluidRow(
                                                           ##column(2, checkboxInput('ms.max', 'Define limits', value=plotparams$ms.max)),
                                                           ##column(2, numericInput( "ms.min.val", "min.", value=plotparams$ms.min.val, step=1)),
                                                           ##column(2, numericInput( "ms.max.val", "max.", value=plotparams$ms.max.val, step=1)),
                                                           column(2, checkboxInput('ms.max', 'Define limits', value=FALSE)),
                                                           column(2, numericInput( "ms.min.val", "min.", value=-4, step=1)),
                                                           column(2, numericInput( "ms.max.val", "max.", value=4, step=1)),

                                                      column(6))
                                                  ),
                                                  tags$br(),tags$hr(),tags$br(),
                                                  fluidPage(
                                                      fluidRow(
                                                          column(12, plotOutput("multi.scatter"))                                                      )
                                                  )
                                                  )

             ###########################
             ## correlation matrix
             ## qc.tabs[['Correlation matrix']] <- tabPanel('Correlation matrix',
             qc.tabs[[5]] <- tabPanel('Correlation matrix',

                                                         fluidPage(
                                                             fluidRow(
                                                                 column(3,  selectInput( "cm.upper", "Upper triangle", c("pearson","spearman","kendall"), selected=plotparams$cm.upper)),
                                                                 column(3,  selectInput( "cm.lower", "Lower triangle", c("pearson","spearman","kendall"), selected=plotparams$cm.lower)),
                                                                 column(1,  checkboxInput('cm.numb', 'Show numbers', value=plotparams$cm.numb)),
                                                                 column(5)
                                                             )
                                                         ),
                                                         tags$br(),tags$hr(),tags$br(),
                                                         fluidPage(
                                                             fluidRow(
                                                                 column(12, plotOutput("correlation.matrix"))
                                                             )
                                                         )
                                                         )
             ###########################
             ## correlation matrix
             ##qc.tabs[['Correlation matrix transposed']] <- tabPanel('Correlation matrix transposed',
             qc.tabs[[7]] <- tabPanel('Correlation matrix transposed',

                                                         fluidPage(
                                                             fluidRow(
                                                                 column(1,  selectInput( "cm.upper", "Upper triangle", c("pearson","spearman","kendall"), selected="pearson")),
                                                                 column(1,  selectInput( "cm.lower", "Lower triangle", c("pearson","spearman","kendall"), selected="spearman")),
                                                                 column(1,  checkboxInput('cm.numb', 'Show numbers', value=FALSE)),
                                                                 column(9)
                                                             ),
                                                             fluidRow(
                                                                 column(11),
                                                                 column(1, downloadButton('downloadCMtrans', 'Download (pdf)'))
                                                             )
                                                         ),
                                                         tags$br(),tags$hr(),tags$br(),
                                                         fluidPage(
                                                             fluidRow(
                                                                 column(12, plotOutput("correlation.matrix.trans"))
                                                             )
                                                         )
                                                         )



            ###################################################################################
            ##
            ##                         insert the tabs
            ##
            ###################################################################################
             navbarPage(title='', id='mainPage',

                        ##if(!is.null(error$msg)) return(),
                        #######################################
                        ##            insert summary tab
                        #######################################
                        summary.tab,
                        #######################################
                        ##              insert heatmap
                        #######################################
                        hm.tab,
                        #######################################
                        ##              insert volcanos
                        #######################################
                        if( !(global.param$which.test %in% c('mod F', 'none'))){
                           ##cat('test volc ins\n')
                           do.call(navbarMenu, volc.tabs)
                       } else {
                           ''
                       },
                       #######################################
                       ##              insert PCA
                       #######################################
                       ##pca.tab,
                       navbarMenu('PCA', pca.tab2[[1]], pca.tab2[[2]]),
                       
                       #######################################
                       ##           insert table preview
                       #######################################
                       table.tab,

                       #######################################
                       ## QC
                       if(global.param$which.test != 'none') {
                           navbarMenu('QC', qc.tabs[[1]], qc.tabs[[2]], qc.tabs[[3]], qc.tabs[[4]], qc.tabs[[5]])
                       } else {
                           navbarMenu('QC', qc.tabs[[1]], qc.tabs[[2]], qc.tabs[[4]], qc.tabs[[5]])
                       },

                       ## #######################################
                       ## export
                       export.tab
                       ) ## end navbarpage
        })

        #########################################################################################
        ##
        ##                                  user input
        ##
        #########################################################################################

        ######################################
        ## 1) UI file upload
        ## - entry point
        ## - session id is generated here
        ##
        output$file.upload <- renderUI({

            if(!is.null(input$file)) return()
            if(!is.null( global.input$file)) return()

            ## ######################################
            ## generate session ID and prepare data
            ## directory
            #########################################

            ## generate 'session id'
            if(is.null(global.param$session))
                global.param$session <- paste(paste(letters[sample(26, 5)], collapse=''), paste(sample(100,5), collapse=''), sep='')

            ## user id
            if(is.null(global.param$user))
                global.param$user <- sub('@.*', '', session$user) ## to avoid problems...

            ##########################################
            ## upload form
            list(
                HTML('<font size=\"3\"><b>Upload file:</b></font>'),
                fileInput("file", "", accept=c('text/csv',
                       'text/comma-separated-values,text/plain',
                       '.csv', '.txt', '.tsv', '.gct')),
                HTML('<hr border-width:\"10px\">')
            )
        })

        ##@####################################
        ## 1a) UI import session
        output$import.session <- renderUI({

            if(!is.null(input$file)) return()
            if(!is.null( global.input$file)) return()

            ## upload form
            list(
                HTML('<font size=\"3\"><b>Import previously saved session:</b></font>'),
                fileInput("session.import", "", accept=c('.RData')),
                HTML('<hr border-width:\"10px\">')
            )

        })

        ##@##################################
        ## 1b) UI browse saved sessions
        ## only available on the server
        output$browse.sessions <- renderUI({

            if(!is.null( global.input$file)) return()
            if(is.null(global.param$user)) return()
            if(length(global.param$user)==0) return()

            ## subfolders in user directory
            saved.sessions <- grep( '_session.RData', dir( paste(DATADIR, global.param$user, sep=''), full.names=T, recursive=T ), value=T )

            ## don't show the panel if there is no saved session
            if(length(saved.sessions) == 0) return()

            ## get the time stamp of the files
            names(saved.sessions) <-  paste( sub('_.*','', sub('.*/','',saved.sessions)), file.info(saved.sessions)$ctime, sep='_' )

            ## store saved sessions
            global.param$saved.sessions <- saved.sessions

            list(
                selectInput('session.browse', paste('Saved sessions (', sub('_at_','@',global.param$user),')',sep=''), choices=sort(names(saved.sessions))),
                actionButton('session.browse.import', 'Import')
            )
        })

        ######################################
        ## 2) UI pick id column
        output$choose.id.column <- renderUI({

            if(global.param$analysis.run) return()

            if(is.null(global.input$table)) return()
            if(!is.null(input$id.col))
                if(input$id.col > 0 && !is.null(input$id.col.value)) return()

            ## get uploaded table and column names
            tab <- global.input$table
            tab.colnames <- global.input$table.colnames

            ## try to find 'id' and move it to the first position
            id.idx <- grep('id|ID', tab.colnames)
            if(length(id.idx) > 0){
                tab.colnames <- c(tab.colnames[id.idx], tab.colnames[-id.idx])
            }

            ## radio button to pick id column
            list(
                ## experimental design
                downloadButton("exportTemplate", 'Export experimental design template'),
                HTML('<br><hr size=\"5\">'),
                radioButtons( "id.col.value", "Choose ID column", tab.colnames),
                actionButton("id.col", 'OK')
            )

        })

        ######################################
        ## 3) UI upload experimental design file
        output$define.groups <- renderUI({

            if(is.null(input$id.col)) return() ## no id colum selected
            if( !is.null(input$id.col))
                if( input$id.col == 0 ) return() ## not pressed yet
            if(!is.null(global.results$data)) return() ## test has been run
            if(!is.null(global.param$grp)){            ## group assignment has been RUN
                if(sum(is.na(global.param$grp)) == 0) return() ## group assignemnt has been DONE
            }

            ## number of assigned groups
            N.grp = global.param$N.grp + 1

            list(
                ## upload template
                fileInput("exp.file", "Upload experimental design file", accept=c('text/plain','.txt')),
                actionButton( 'update.grp', 'Next')
            )
        })

        ######################################
        ## UI filter type
        output$filter.type <- renderUI({
            if(!global.param$analysis.run) return()

            ## if a test has been performed
            if(global.param$which.test != 'none')
                 res <- list( selectInput('filter.type', 'Filter based on:', c('nom.p', 'adj.p', 'top.n', 'none'), selected=global.param$filter.type) )
             else
                res <- list(selectInput('filter.type', 'Filter based on:', c('none'), selected='none'))
            res
        })

        ######################################
        ## UI conditional filter value
        output$filter.value <- renderUI({

          if(!global.param$analysis.run) return()
        
          
          res <- list(
                  conditionalPanel(condition = "input['filter.type'] == 'top.n'", numericInput( "filter.value.top.n", "Top N features", value=50, min=2, step=1)),
                  conditionalPanel(condition = "input['filter.type'] == 'nom.p'", numericInput( "filter.value.nom.p", "P-value filter", value=0.01, min=0, max=1, step=1e-2)),
                  conditionalPanel(condition = "input['filter.type'] == 'adj.p'", numericInput( "filter.value.adj.p", "Corrected P-Value (FDR)", value=0.05, min=0, max=1, step=1e-2))
                )
          
          res
        })


        #####################################
        ## 6) UI select test
        output$list.groups <- renderUI({

            if( !global.param$grp.done ) return()

            list(
                radioButtons('log.transform', 'Log-transformation', choices=c('none', 'log10', 'log2'), selected=global.param$log.transform),
                radioButtons('norm.data', 'Data normalization', choices=c('Median', 'Median-MAD', '2-component', 'Quantile', 'none'), selected=global.param$norm.data),
                radioButtons('repro.filt', 'Reproducibility filter (beta)', choices=c('yes', 'no'), selected=global.param$repro.filt),
                radioButtons('which.test', 'Select test', choices=c('One-sample mod T', 'Two-sample mod T', 'mod F', 'none'), selected=global.param$which.test),

                actionButton('run.test', 'Run analysis!')
            )
        })

        #############################################################################
        ## observer 
        ##                      perform PCA analysis
        ##
        #############################################################################
        ##observeEvent(input$run.pca, {
    
    
    
        ##})
        #############################################################################
        ## observer
        ##                  export all analysis results
        ##
        ## - generate a zip-file
        #############################################################################
        observeEvent(input$export.results, {

            ##cat('User:', session$user, '\n')
            if(!is.null(error$msg)) return()

            ## update label
            global.param$label <- gsub('_| |,|;|\\:|\\+|\\*', '-', input$label)


            ###############################
            ## apply filter
            filter.res()
            res = global.results$filtered

            #######################################
            ## extract expression values
            res = res[, names(global.param$grp)]

            ## groups to compare
            grp.comp <- unique( global.param$grp.comp )


            #############################################################
            ##                correlation matrix
            #############################################################
            if(input$export.cm){
                withProgress(message='Exporting', detail='correlation matrix',{
                fn.cm <- paste(global.param$session.dir, '/correlation_matrix_lo_',input$cm.lower, '_up_',input$cm.upper, '.pdf', sep='')
                plotCorrMat(lower=input$cm.lower, upper=input$cm.upper, display_numbers=F, filename=fn.cm)
                })
            }
            ############################################################
            ##                   heatmap
            ## require at least three significant hits
            ############################################################
            if(input$export.hm){

                ##filter.res()
                ##res = global.results$filtered

                if(nrow(res) >= 3){
                    withProgress(message='Exporting', detail='heatmap',{
                    fn.hm <- paste(global.param$session.dir, 'heatmap.pdf', sep='/')
                    ## heatmap title
                    hm.title <- paste('filter:', global.param$filter.type, ' / cutoff:', global.param$filter.value, sep='')
                    hm.title <- paste(hm.title, '\nsig / total: ', nrow(res), ' / ', nrow( global.results$data$output ), sep='')

                    if(input$hm.max){
                        plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, max.val=input$hm.max.val, style=global.param$which.test, filename=fn.hm, cellheight=min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered))

                    } else {
                        plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, style=global.param$which.test, filename=fn.hm, cellheight= min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered))
                    }
                    })
                } ## end if nrow(res)>3

            }


            ############################################################
            ##                   volcanos
            ############################################################
            if(input$export.volc & !(global.param$which.test %in% c('mod F', 'none'))){
                withProgress(message='Exporting', detail='volcano plot',{
                fn.volc <- paste(global.param$session.dir, 'volcano.pdf', sep='/')

                    pdf(fn.volc, height=11, width=11)
                    for(j in 1:length(grp.comp)){
                        local({
                            my_j=j
                            plotVolcano(grp.comp[my_j], max.logP=input$max.logP)
                        })
                    }
                dev.off()
                })
            }
            ############################################################
            ##                 PCA
            ############################################################
            if(input$export.pca){

                withProgress(message='Exporting', detail='pca',{
                fn.volc <- paste(global.param$session.dir, 'pca.pdf', sep='/')
                pdf(fn.volc, height=5, width=15)
                pca=plotPCA()
                dev.off()

                })
            }
            ############################################################
            ##                    boxplots
            ############################################################
            if(input$export.box){
                withProgress(message='Exporting', detail='box plot',{
                    fn.box <- paste(global.param$session.dir, 'boxplots_unnormalized.pdf', sep='/')

                    ###############################################
                    ## unnormalized ratios
                    if(is.null(global.results$table.log))
                        tab <- data.frame(global.input$table)
                    else
                        tab <- data.frame(global.results$table.log)

                    ## id column
                    id.col.value <- global.param$id.col.value
                    ## group vector
                    grp <- global.param$grp
                    ## group colors
                    grp.col <- global.param$grp.colors
                    grp.col.leg <- global.param$grp.colors.legend

                    ## pdf
                    pdf(fn.box, 12, max(3, .8*ncol(global.input$table)))
                    makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg)
                    dev.off()

                    ################################################
                    ## normalized
                    if(!is.null(global.results$table.norm) ){
                        fn.box <- paste(global.param$session.dir, paste('boxplots_', global.param$norm.data,'.pdf', sep=''), sep='/')
                        ## normalized ratios
                        tab <- data.frame(global.results$table.norm)
                        ## pdf
                        pdf(fn.box, 12, max(3, .8*ncol(global.input$table)))
                        makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg)
                        dev.off()
                    }
                })
            }

            ############################################################
            ##                profile plots
            ############################################################
             if(input$export.profile){
                withProgress(message='Exporting', detail='profile plot',{
                    fn.profile <- paste(global.param$session.dir, 'profile_plot.pdf', sep='/')

                    ###############################################
                    ## unnormalized ratios
                    if(is.null(global.results$table.log))
                        tab <- data.frame(global.input$table)
                    else
                        tab <- data.frame(global.results$table.log)

                    ## id column
                    id.col.value <- global.param$id.col.value
                    ## group vector
                    grp <- global.param$grp
                    ## group colors
                    grp.col <- global.param$grp.colors
                    grp.col.leg <- global.param$grp.colors.legend

                    ################################################
                    ## normalized
                    if(!is.null(global.results$table.norm) ){
                        pdf(fn.profile, 14, 7)
                        par(mfrow=c(1,2))

                        ## normalized ratios
                        tab.norm <- data.frame(global.results$table.norm)
                        makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main='Before normalization')
                        makeProfileplot(tab.norm, id.col.value, grp, grp.col, grp.col.leg, main=paste(global.param$norm.data, 'normalized'))
                        dev.off()

                    } else{
                        pdf(fn.profile, 7, 7)
                        par(mfrow=c(1,1))
                        makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main='unnormalized')
                        dev.off()

                    }
                })
            }

            ############################################################
            ##                 multi scatter
            ############################################################
            if(input$export.ms){
                withProgress(message='Exporting', detail='multiscatter',{
                fn.ms <- paste(global.param$session.dir, 'multiscatter.pdf', sep='/')
                pdf(fn.ms, height=120*ncol(global.input$table)*(11/800), width=120*ncol(global.input$table)*(11/800))
                plotMultiScatter( define.max=input$ms.max, min.val=input$ms.min.val, max.val=input$ms.max.val )
                dev.off()
                })
            }

            ############################################################
            ##                   p-values
            ############################################################
            if(input$export.phist & global.param$which.test != 'none'){
                withProgress(message='Exporting', detail='p-value histogram',{
                fn.pval <- paste(global.param$session.dir, 'histogram_P-values.pdf', sep='/')

                ## unfiltered results
                res.all = global.results$data$output

                pdf(fn.pval, 10, 5*ifelse( global.param$which.test != 'mod F', length(grp.comp), 1 ))

                ############################################
                ## mod T
                if(!(global.param$which.test %in% c('mod F'))){
                    par(mfrow=c(length(grp.comp),1))
                    for(g in grp.comp){
                        pval <- res.all[, paste('P.Value', g, sep='.')]
                        hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=2.2, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                        legend('top', legend=g, cex=2)
                    }
                 ############################################
                 ## mod F
                } else {
                    pval <- res.all[, paste('P.Value')]
                    hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=2.2, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                    ## legend('top', legend=paste(groups), cex=2)
                }
                dev.off()
                })

            }

            #########################################################
            ##               Excel sheet
            #########################################################
            if(input$export.excel){
                withProgress(message='Exporting', detail='Excel sheet',{
                    res.comb <- global.results$data$output
                    tmp <- sort(global.param$grp)

                    ## append annotation columns
                    if(!is.null(global.input$table.anno))
                        res.comb <- cbind(res.comb, Annotation.starts.here=rep('', nrow(res.comb)), global.input$table.anno)
                    expDesign <- data.frame(Column=names(tmp), Experiment=tmp)

                    ## generate_filename
                    fn.tmp <- sub(' ','_', paste(global.param$session.dir, '/', 'results_', sub(' ', '_',global.param$which.test),  ifelse(global.param$log.transform != 'none', paste('_', global.param$log.transform, sep=''), '_'), ifelse(global.param$norm.data != 'none', paste('_', global.param$norm.data, sep=''), '_'), ifelse(input$repro.filt=='yes', paste('_reprofilt', sep=''), '_'), sub(' .*', '', Sys.time()),".xlsx", sep=''))
                    global.param$ExcelFileName <- fn.tmp
                    ## Excel
                    WriteXLS(c('res.comb', 'expDesign'), ExcelFileName=fn.tmp, FreezeRow=1, FreezeCol=1, SheetNames=c('modT', 'class vector'), row.names=F, BoldHeaderRow=T, AutoFilter=T)

                })
            }

            #########################################################
            ##          save session parameters
            #########################################################
            global.input.imp <- reactiveValuesToList(global.input)
            global.param.imp <- reactiveValuesToList(global.param)
            global.results.imp <- reactiveValuesToList(global.results)
            
            #########################################################
            ## save current plotting parameters
            #########################################################
            
            ## heatmap
            plotparams$hm.scale <- input$hm.scale
            plotparams$hm.clust <- input$hm.clust
            plotparams$hm.cexCol <- input$hm.cexCol
            plotparams$hm.cexRow <- input$hm.cexRow
            plotparams$hm.max <- input$hm.max
            plotparams$hm.max.val <- input$hm.max.val
            ## pca
            plotparams$pca.x <- input$pca.x
            plotparams$pca.y <- input$pca.y
            plotparams$pca.z <- input$pca.z
            ## multiscatter
            plotparams$ms.max <- input$ms.max
            plotparams$ms.min <- input$ms.min
            plotparams$ms.max <- input$ms.max
            ## correlation matrix
            plotparams$cm.upper <- input$cm.upper
            plotparams$cm.lower <- input$cm.lower
            plotparams$cm.numb <- input$cm.numb
            
            ## convert to list
            plotparams.imp <- reactiveValuesToList(plotparams)

            ## volcano coordinates
            volc.imp <-  reactiveValuesToList(volc)

            
            
            #################################
            ## save as R-object
            ## no label present
            if(is.null(global.param$label)){

                save(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp, file=paste(global.param$session.dir, 'session.RData', sep='/'))
                fn.zip <- paste( gsub('\\:', '', gsub(' ','-', gsub('-','',Sys.time()))),'.zip', sep='')
            }
            ## label present
            if(!is.null(global.param$label) | nchar(global.param$label) == 0){
                save(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp, file=paste(global.param$session.dir, paste(global.param$label,'_session.RData', sep=''), sep='/'))
                fn.zip <- paste( global.param$label, '_', gsub('\\:', '', gsub(' ','-', gsub('-','',Sys.time()))),'.zip', sep='')
            }

            #########################################################
            ##   export parameters as small text file
            #########################################################
            params <- global.param.imp[c('log.transform', 'norm.data', 'repro.filt' , 'which.test', 'filter.type', 'filter.value')]

            params.txt <- unlist(lapply(params, paste, collapse=';'))
            params.txt <-  paste(names(params.txt),params.txt, sep='\t')

            ## hostname
            params.txt <- c(paste('## hostname: ', session$clientData$url_hostname, sep=''), '' , params.txt)

            ## user names
            params.txt <- c(paste('## user: ', session$user, sep=''), '' , params.txt)

            ## session id
            params.txt <- c(paste('## session id: ', global.param$session ), params.txt)

            ## version
            params.txt <- c(paste('## ', APPNAME, ' (v', VER, ')', sep='') , params.txt)

            ## add date and time
            params.txt <- c(paste('##', as.character(Sys.time())), params.txt)

            ## export
            writeLines(params.txt, con=paste(global.param$session.dir, 'params.txt', sep='/'))

            ##############################################################
            ##            create an archive
            ##############################################################
            ## timestamp as filename
	                ## file names to zip
	    ##fn.all <- grep('pdf$|xlsx$|RData$|txt$',  dir(global.param$session.dir) , value=T)
	    ##fn.all.abs <- grep('pdf$|xlsx$|RData$|txt$', dir(global.param$session.dir, full.names=T), value=T)
            fn.all <- grep('pdf$|xlsx$|txt$|gct$|RData$',  dir(global.param$session.dir) , value=T, ignore.case=T)
	    fn.all.abs <- grep('pdf$|xlsx$|txt$|gct$|RData$', dir(global.param$session.dir, full.names=T, ignore.case=T), value=T)

            ## #################################################
            ## handle special characters in file names
            ## #################################################

            ## for windows: "
            fn.all.abs <- paste('"',fn.all.abs,'"', sep='')
            ## unix/linux: '
            fn.all <- paste('\'',fn.all,'\'', sep='')

            ###################################################
            ## run command
	    if(OS == 'Windows')
                system( paste('zip -0 ', paste(global.param$session.dir, fn.zip, sep='/'), ' ', paste(fn.all.abs, collapse=' '),sep='') )
            else
                system( paste('cd ', global.param$session.dir,' && zip -0 ', fn.zip, ' ', paste(fn.all, collapse=' '), sep='') )

            ## store file.name
	    global.param$zip.name=fn.zip
            ## cat('test16\n')

             ###############################################################
             ## remove archived files
	     file.remove(gsub('"|\'', '', fn.all.abs[-grep('\\.RData$', fn.all.abs)]) )

             ###############################################################
             ## flag export
             global.results$export.results=T

             ## redirect to the same panel
             updateTabsetPanel(session, 'mainPage', selected='Export')
        })


        ###################################################################################
        ##
        ##                             Do the actual computation
        ##
        ###################################################################################
      
        
        
        ###############################################
        ## 4) initialize group assignment
        observeEvent( input$id.col ,{

            if( is.null( global.input$table) | is.null(input$id.col.value) ) return()


            ## store name of id column
            global.param$id.col.value <- input$id.col.value
            ## update 'input$id.col'
            global.input$id.col <- input$id.col


            #############################################
            ## check the id column
            tab <- global.input$table

            ## make sure the ids are unique
            ids <- make.names( make.unique(as.character(tab[, global.param$id.col.value]), sep='_') )
            ## replace values in id column
            tab[, global.param$id.col.value] <- ids

            ##View(tab[, global.input$id.col.value])
            ##cat(global.input$id.col.value)

            ## use id as rownames
            rownames(tab) <- ids

            ##View(tab)

            ########################################
            ## store
            global.input$table <-  tab

            #############################################
            ## initialize group assignemnt
            groups <- rep(NA, ncol(global.input$table))
            names(groups) <- colnames(global.input$table)

            ## remove id column
            groups <- groups[-c( which(global.param$id.col.value == names(groups))) ]

            ## set group assingment
            global.param$grp <- groups
            ## set number of assinged groups
            global.param$N.grp <- 0

            ##View(global.input$table)
        })

        #################################################################################
        ##
        ## 2) - upload file
        ##    - import file
        ##    - folders are create here
        ##    - extract label from filename
        #################################################################################
        observeEvent( input$file, {

            ##
            global.input$id.col <- 0

            ########################################
            ## generate session ID and prepare data
            ## directory
            #########################################

            ## ## if there is an user ID...
            if(!is.null( global.param$user )){
                 ## create user directory, if not present already
                 if(!dir.exists(paste(DATADIR, global.param$user, sep='')))
                     dir.create(paste(DATADIR, global.param$user, sep=''))

                 global.param$session.dir <- paste(DATADIR, global.param$user,'/' ,global.param$session, '/', sep='')

            } else{
                 global.param$session.dir <- paste(DATADIR, global.param$session, '/' ,sep='')
            }
            ## ## create directory on server to store the results
            dir.create(global.param$session.dir)

            ##############################################
            ## copy the input file to the session folder
            fn <- paste0( global.param$session.dir, input$file$name)
            file.copy(input$file$datapath, fn)

            ##@###############################
            ## generate label
            fn.split <- unlist(strsplit( sub('.*/', '', fn), '_'))
            if(length(fn.split) > 1){
                label <- fn.split[1]
                if(nchar(label) > 10)
                    label <- chopString(label, 10, add.dots=F)
                global.param$label <- label
            } else {
                global.param$label <- chopString( sub('.*/', '', fn) , 10, add.dots=F)
            }


            ## ################################
            ## GCT ?
            if( length( grep( '^\\#1\\.', readLines(fn,n=1))) > 0){
                tab <- read.delim( fn, stringsAsFactors=F, na.strings=NASTRINGS, skip=2)
            } else {

                ## ################################
                ## determine the separator
                tab.sep=NULL
                ## try to figure out the separator, DON'T USE THE HEADER FOR THAT
                ## use the fourth row instead (should be data)
                for(s in SEPARATOR){

                    ##tab <- read.table(fn, sep=s, header=T, stringsAsFactors=F, nrows=1, skip=3)
                    tab <- read.table(fn, sep=s, header=F, stringsAsFactors=F, nrows=1, skip=4)

                    if(length(tab) > 1){
                        global.param$tabsep <- s
                        break;
                    }
                }
                ## #########################################################
                ## import the table: txt
                if( global.param$tabsep == '\t'){
                    tab <- read.delim( fn, stringsAsFactors=F, na.strings=NASTRINGS)
                } else {
                    tab <- read.table( fn, sep=global.param$tabsep, header=T, stringsAsFactors=F, na.strings=NASTRINGS, quote = "\"", dec = ".", fill = TRUE, comment.char = "")
                }

            }## end if GCT

            ## shorten column names and store together with the original names
            colnames.tmp <- chopString(colnames(tab), STRLENGTH)
            names(colnames.tmp) <- colnames(tab)

            ## store values
            global.input$table <- global.input$table.org <- tab
            global.input$file <- input$file
            global.input$table.colnames <- colnames.tmp

            rm(tab, colnames.tmp)
        })

        ##@###############################################################
        ##
        ## import session via file upload
        ##
        ##@###############################################################
        observeEvent(input$session.import, {

            #################################
            ## import workspace
            load( input$session.import$datapath )

            #################################
            ## assign the imported values to the global reactive variables
            for(i in names(global.input.imp)){
                global.input[[i]] <- global.input.imp[[i]]
            }
            for(i in names(global.param.imp)){
                global.param[[i]] <- global.param.imp[[i]]
                ##cat(i,'\t',global.param[[i]], '\n')
            }
            for(i in names(global.results.imp)){
                global.results[[i]] <- global.results.imp[[i]]
            }
            for(i in names(plotparams.imp)){
                plotparams[[i]] <- plotparams.imp[[i]]
            }
            for(i in names(volc.imp)){
                volc[[i]] <- volc.imp[[i]]
            }

            ## ################################
            ## update filter
            if(global.param$filter.type == 'top.n'){
                updateNumericInput(session, inputId='filter.value.top.n', value=global.param$filter.value)
            }
            if(global.param$filter.type == 'nom.p'){
                updateNumericInput(session, inputId='filter.value.nom.p', value=global.param$filter.value)
            }
            if(global.param$filter.type == 'adj.p'){
                updateNumericInput(session, inputId='filter.value.adj.p', value=global.param$filter.value)
            }
          
          ## ##############################################################
          ##                 update plotting parameters
          ## ##############################################################
          
          ## heatmap
          updateNumericInput(session, inputId='hm.cexCol', value=plotparams$hm.cexCol)
          updateNumericInput(session, inputId='hm.cexRow', value=plotparams$hm.cexRow)
          updateSelectInput(session, inputId='hm.scale', selected=plotparams$hm.scale)
          updateSelectInput(session, inputId='hm.clust', selected=plotparams$hm.clust)
          updateNumericInput(session, inputId='hm.max.val', value=plotparams$hm.max.val)
          updateCheckboxInput(session, inputId='hm.max', value=plotparams$hm.max)
          ## hm clust missing
          
          ## PCA
          updateSelectInput(session, inputId='pca.x', selected=plotparams$pca.x)
          updateSelectInput(session, inputId='pca.y', selected=plotparams$pca.y)
          updateSelectInput(session, inputId='pca.z', selected=plotparams$pca.z)
          
          ## multiscatter
          updateCheckboxInput(session, inputId='ms.max', value=plotparams$ms.max)
          updateNumericInput(session, inputId='ms.max.val', value=plotparams$ms.max.val)
          updateNumericInput(session, inputId='ms.min.val', value=plotparams$ms.min.val)
          
          ## correlation matrix
          updateCheckboxInput(session, inputId='cm.numb', value=plotparams$cm.numb)
          updateSelectInput(session, inputId='cm.upper', selected=plotparams$cm.upper)
          updateSelectInput(session, inputId='cm.lower', selected=plotparams$cm.lower)
          

            ##################################
            ## set flags
            global.param$session.imported=T
            global.param$analysis.run=T

            global.param$session.import.init=T

            global.results$export.results=F

            ##################################
            ## clean up
            rm(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp)

            ###################################################################
            ##            insert the panels for the volcanos
            ###################################################################
            if(!(global.param$which.test %in% c('mod F', 'none'))){
                ins.volc()
            }
        })

        ##@###############################################################
        ##
        ## import saved session from the server via drop down menu
        ##
        ##@###############################################################
        observeEvent(input$session.browse.import, {

            ##@ ###############################
            ## import workspace
            ## identify selected session file
            load(global.param$saved.sessions[[ input$session.browse ]])

            ##@###############################
            ## assign the imported values to the global reactive variables
            for(i in names(global.input.imp)){
                global.input[[i]] <- global.input.imp[[i]]
            }
            for(i in names(global.param.imp)){
                global.param[[i]] <- global.param.imp[[i]]
                ##cat(i,'\t',global.param[[i]], '\n')
            }
            for(i in names(global.results.imp)){
                global.results[[i]] <- global.results.imp[[i]]
            }
            for(i in names(plotparams.imp)){
                plotparams[[i]] <- plotparams.imp[[i]]
            }
            for(i in names(volc.imp)){
                volc[[i]] <- volc.imp[[i]]
            }

            ## ##############################################################
            ##                       update filter
            ## ##############################################################
            if(global.param$filter.type == 'top.n'){
                updateNumericInput(session, inputId='filter.value.top.n', value=global.param$filter.value)
            }
            if(global.param$filter.type == 'nom.p'){
                updateNumericInput(session, inputId='filter.value.nom.p', value=global.param$filter.value)
            }
            if(global.param$filter.type == 'adj.p'){
                updateNumericInput(session, inputId='filter.value.adj.p', value=global.param$filter.value)
            }

            ## ##############################################################
            ##                 update plotting parameters
            ## ##############################################################

            ## heatmap
            updateNumericInput(session, inputId='cexCol', value=plotparams$hm.cexCol)
            updateNumericInput(session, inputId='cexRow', value=plotparams$hm.cexRow)
            updateSelectInput(session, inputId='hm.scale', selected=plotparams$hm.scale)
            updateSelectInput(session, inputId='hm.clust', selected=plotparams$hm.clust)
            updateNumericInput(session, inputId='hm.max.val', value=plotparams$hm.max.val)
            updateCheckboxInput(session, inputId='hm.max', value=plotparams$hm.max)
            ## hm clust missing

            ## PCA
            updateSelectInput(session, inputId='pca.x', selected=plotparams$pca.x)
            updateSelectInput(session, inputId='pca.y', selected=plotparams$pca.y)
            updateSelectInput(session, inputId='pca.z', selected=plotparams$pca.z)

            ## multiscatter
            updateCheckboxInput(session, inputId='ms.max', value=plotparams$ms.max)
            updateNumericInput(session, inputId='ms.max.val', value=plotparams$ms.max.val)
            updateNumericInput(session, inputId='ms.min.val', value=plotparams$ms.min.val)

            ## correlation matrix
            updateCheckboxInput(session, inputId='cm.numb', value=plotparams$cm.numb)
            updateSelectInput(session, inputId='cm.upper', selected=plotparams$cm.upper)
            updateSelectInput(session, inputId='cm.lower', selected=plotparams$cm.lower)



            ##################################
            ## set flags
            global.param$session.imported=T
            global.param$analysis.run=T

            global.param$session.import.init=T

            global.results$export.results=F

            ##################################
            ## clean up
            rm(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp)

            ###################################################################
            ##            insert the panels for the volcanos
            ###################################################################
            if(!(global.param$which.test %in% c('mod F', 'none'))){
                ins.volc()
            }
        })



        ##@###############################################################
        ## 4c)       upload experimental design file
        ##
        ## - divide input table into expression and annotation columns
        observeEvent( input$exp.file, {

            ## reset error message
            error$msg <- NULL

            #############################
            ## copy file into sessions folder
            fn <- paste0( global.param$session.dir, input$exp.file$name)
            file.copy(input$exp.file$datapath, fn)


            ############################
            ## read the file
            ##grp.file <- read.delim(input$exp.file$datapath, header=T, stringsAsFactors=F)
            grp.file <- read.delim(input$exp.file$datapath, header=T, stringsAsFactors=F)
            Column.Name <- grp.file$Column.Name
            Experiment <- grp.file$Experiment

            ###############################################################
            ## index on non-empty 'Experiment' rows
            exprs.idx <- which(nchar(Experiment) > 0 )


            ##@###############################
            ## update label
            fn.split <- unlist(strsplit( sub('.*/', '', fn), '_'))
            if(length(fn.split) > 1){
                label <- fn.split[1]
                if(nchar(label) > 10)
                    label <- chopString(label, 10, add.dots=F)
                global.param$label <- paste(global.param$label, label )
            } else {
                label <- chopString( sub('.*/', '', fn) , 10, add.dots=F)
                global.param$label <- paste(global.param$label, label, sep='-')
            }


            ###############################################################
            ##
            ##                   do some sanity checks
            ##
            ###############################################################

            ## names in the exp design file do not match to the table
            if( sum( Column.Name != colnames(global.input$table)) > 0 ){
                error$msg <- 'Experimental design files does not match the table you have uploaded!'
                return()
            }

            ## not an experimental design file
            if( sum( colnames(grp.file) %in% c('Column.Name', 'Experiment'), na.rm=T) != 2 )  {
                error$msg <- 'This is not an experimental desgin file!\n\nThe file should contain two columns (Column.Name, Experiment)!'
                return()
            }
            ## 'empty' file
            if( sum( nchar(Experiment) > 0 ) == 0 | sum(!is.na( Experiment) == 0) ){
                error$msg <- 'No experiments defined!'
                return()
            }
            ##cat('L=', sum( Column.Name[ exprs.idx ] %in%  colnames(global.input$table)))
            ## column names specified in exp design file not found in table
            ##if( sum( Column.Name[ exprs.idx ] %in%  colnames(global.input$table)) != length(exprs.idx) ){
            ##    error$msg <- 'Column names in the experimental design file cannot be found in the data table!'
            ##    return()
           ## }
            ## check whether there are at least 2 replicates per group
            num.rep=table(Experiment[exprs.idx])
            ##if(min(num.rep) == 1){
            ##    error$msg <- paste('No replicate measurements defined!')
            ##    return()
            ##}

            ##################################
            ## ANNOTATION: extract empty cells
            ## - corresponding columns will be carried over as
            ##   annotation columns in the result file
            grp.anno <- grp.file[which(nchar(grp.file$Experiment) == 0 ), ]
            grp.anno <- setdiff( grp.anno$Column.Name, global.param$id.col.value )
            if(length(grp.anno)>0)
                global.input$table.anno <- global.input$table[ , grp.anno]

            ##cat('test')
            ##################################
            ## EXPRESSION
            ## - extract all non-empty cells in the 'Experiment' column
            grp.exprs <- grp.file[exprs.idx, ]

            ## class vector
            grp=grp.exprs$Experiment
            names(grp)=grp.exprs$Column.Name

            ## update input table, keep id and expression columns
            global.input$table <- global.input$table[ , c(global.param$id.col.value, names(grp))]

            ################################
            ## update number of groups
            global.param$N.grp <- length(unique( na.omit(grp)) )
            ## store group assignment
            global.param$grp <- grp
            ## group colors
            grp.col <- rep(GRPCOLORS[1], length(grp))
            for(i in 2:length(unique(grp))) grp.col[ which(grp == unique(grp)[i]) ] <- GRPCOLORS[i]
            global.param$grp.colors <- grp.col

            ## group colors for figure legend
            idx <- !duplicated(grp)
            grp.col.legend = grp.col[idx]
            names(grp.col.legend) <- grp[idx]
            global.param$grp.colors.legend <- grp.col.legend

            ## all done
            global.param$grp.done = T

            ## save column name used as 'id'
            ##global.param$id.col.value = input$id.col.value

        })

        ################################################################################
        ##
        ##                once the 'run test' button was pressed...
        ##
        ## 1) log-transform (optional)
        ## 1) normalization (optional)
        ## 2) reproducibility filter (optional)
        ## 3) test (optional)
        ##
        ################################################################################
        observeEvent(input$run.test, {

            ## reset any error messages
            error$msg <- NULL

            global.input$run.test <- input$run.test

            ##View(global.input$table)

            ###########################################
            ## - store which test has been used
            ## - needed to supress volcanos for mod F test
            global.param$which.test <- input$which.test
            global.param$repro.filt <- input$repro.filt
            global.param$norm.data <- input$norm.data
            global.param$log.transform <- input$log.transform


            #####################################################################
            ## if the 'Run test' - button has been pressed for the first time,
            ## store a copy of the original input matrix (unnormalized, unfiltered)
            ##if (global.input$run.test == 1){
            if(!(global.param$analysis.run)){
                global.input$table.org <- global.input$table
                tab <- data.frame(global.input$table)
            }
            ##if(global.input$run.test > 1 ){
            if(global.param$analysis.run){
                tab <- data.frame(global.input$table.org)
            }
            ##View(tab)
            ## id column
            id.col = global.param$id.col.value
            ## all group labels
            groups=global.param$grp
            ##View(tab[, id.col])
            ###############################################
            ## initialize values for normalized and filtered matrix
            global.results$table.norm=NULL
            global.results$table.repro.filt=NULL
            global.results$pca=NULL
            global.results$table.log=NULL
            global.results$repro.filt=NULL

            ###############################################
            ## determine which test should be performed
            test = global.param$which.test
            norm.data = global.param$norm.data
            repro.filt = global.param$repro.filt
            log.trans = global.param$log.transform

            ###############################################
            ## specify which comparisons should be performed
            if(test %in% c('One-sample mod T', 'mod F', 'none')){
                ## each group separetely
                groups.comp <- global.param$grp
                global.param$grp.comp <- groups.comp
            }
            ## #############################################
            ##
            if(test == 'Two-sample mod T'){

                ## all pairwise combinations
                groups.unique <- unique(global.param$grp)

                groups.comp <- c()
                count=1
                for(i in 1:(length(groups.unique)-1))
                    for(j in (i+1):length(groups.unique)){
                        groups.tmp <- sort( groups.unique[c(i,j)] )
                        ##groups.comp[count] <- paste(groups.unique[i], groups.unique[j], sep='.vs.')
                        groups.comp[count] <- paste(groups.tmp[1], groups.tmp[2], sep='.vs.')
                        count <- count+1
                    }
                global.param$grp.comp <- groups.comp
            }

            #############################################
            ## log transformation
            #############################################
            if(log.trans != 'none'){
                ids.tmp <- tab[, id.col]
                dat.tmp <- tab[, -which(colnames(tab) == id.col)]
                dat.tmp <- data.matrix(dat.tmp)

                dat.tmp[dat.tmp == 0] <- NA

                if(log.trans == 'log2'){
                    dat.tmp <- log(dat.tmp, 2)
                }
                if(log.trans == 'log10'){
                    dat.tmp <- log(dat.tmp, 10)
                }
                ## putting a dataframe around here turns out to be ESSENTIAL!! DON'T USE CBIND HERE!
                tab <- data.frame( ids.tmp, dat.tmp)
                colnames(tab)[1] <- id.col
                ## store
                global.results$table.log <- tab
            }

            #############################################
            ## normalization
            #############################################
            if(norm.data != 'none'){
                ##tab.org = tab
                withProgress(message='Applying normalization...', {
                    tab <- normalize.data(tab, id.col, norm.data)
                    if(is.null(dim(tab)) | unlist(tab)[1] == 'No_success'){

                        error$msg <- paste('Error in Two-component normalization:<br><br>Could not fit mixture model for data column:<br><br>', tab, '<br><br>Giving up...')

                        ## if not successful skip the rest
                        test='none'
                        repro.filt='no'

                    } else {
                        global.results$table.norm <- tab
                        ##View(tab)
                    }
                })
            }
            ##############################################
            ##
            ## reproducibility filter
            ## - only for one-sample test
            ##
            ##############################################
            if(repro.filt == 'yes'){

                if( test == 'One-sample mod T'){

                    withProgress(message='Applying reproducibility filter',  {
                        repro = my.reproducibility.filter(tab, id.col=id.col, groups, alpha=0.05)
                        tab = repro$table
                        ##View(repro$table)
                    })
                    ## store indices of filtered values in the original table
                    global.results$repro.filt <- repro$values.filtered
                    global.results$table.repro.filt <- tab

                } else {
                    global.param$repro.filt <- 'no'
                }
            }
            ###############################################################################
            ##
            ##                                     TEST
            ##
            ###############################################################################

            ##################################
            ## two sample
            if(test == 'Two-sample mod T'){
                ##View(tab)
                withProgress(message='Two-sample test', value=0, {

                    count=0
                    ## loop over groups
                    for(g in unique(groups.comp)){

                        ## extract current groups
                        groups.tmp <- groups[ c(grep( paste('^',unlist( strsplit(g, '\\.vs\\.'))[1],'$', sep='') , groups), grep(paste('^',unlist( strsplit(g, '\\.vs\\.'))[2], '$', sep='') , groups)) ]

                        ## extract table of current group
                        tab.group <- cbind(tab[, id.col], tab[, names(groups.tmp)])
                        colnames(tab.group)[1] <- id.col


                        #############################
                        ## the actual test
                        #############################
                        res.tmp <-  modT.test.2class( tab.group, groups=groups.tmp, id.col=id.col, label=g )$output

                        if(count == 0){
                            res.comb <- res.tmp
                        } else {
                            ## make sure the order is correct
                            if(nrow(res.tmp ) != nrow(res.comb)) stop( "number of rows don't match!\n" )
                            res.tmp <- res.tmp[rownames(res.comb), ]
                            ##res.comb <- cbind(res.comb, res.tmp)
                            res.comb <- data.frame(res.comb, res.tmp, stringsAsFactors=F)
                        }
                        ##################################################
                        ## progress bar
                        incProgress(count/length(unique(groups.comp)), detail=g)
                        count=count + 1

                    }

                ##################################
                ## reorder table
                res.id <- res.comb$id ## id column
                res.exprs <- res.comb[, names(groups)] ## expression values
                res.test <- res.comb[, grep('^logFC|^AveExpr|^t\\.|^P\\.Value|^adj.P.Val|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                res.test <- res.test[, order(colnames(res.test))]

                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                res.comb <- res.comb[rownames(tab),]

                global.results$data$output <- res.comb


                })
            }
            ##################################
            ## one sample
            if(test == 'One-sample mod T'){
               ## cat('test...')
                withProgress(message='One-sample test', value=0, {

                    count=0
                    ## loop over groups
                    for(g in unique(groups.comp)){

                       ## setProgress(detail=g)

                        ## extract table of current group
                        tab.group <- cbind(tab[, id.col], tab[, names(groups)[which(groups == g)]])
                        colnames(tab.group)[1] <- id.col

                        ##View(tab.group)

                        res.tmp <- modT.test( tab.group, id.col=id.col, plot=F, nastrings=NASTRINGS, label=g, na.rm=FALSE)$output
                        ##View(res.tmp)
                        if(count == 0){
                            res.comb <- res.tmp
                        } else {
                            if(nrow(res.tmp ) != nrow(res.comb)) stop( "number of rows don't match!\n" )
                            res.tmp <- res.tmp[rownames(res.comb), ]
                            res.comb <- cbind(res.comb, res.tmp)
                            ##res.comb <- merge(res.comb, res.tmp, sort=F)
                            ##res.comb <- merge(res.comb, res.tmp, by='id')
                        }

                        #############################################
                        ## progress bar
                        ##incProgress(1/length(unique(groups.comp)))
                        incProgress(count/length(unique(groups.comp)), detail=g)
                        count=count + 1
                    }
                })

                ##################################
                ## reorder columns of the table
                res.id <- res.comb$id ## id column
                res.exprs <- res.comb[, names(groups)] ## expression values
                ##View(res.exprs)
                res.test <- res.comb[, grep('^logFC|^AveExpr|^t\\.|^P\\.Value|^adj.P.Val|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                ##View(res.test)
                res.test <- res.test[, order(colnames(res.test))]
                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                ##res.comb <- res.comb[tab[, id.col], ]
                res.comb <- res.comb[rownames(tab),]
                ###########################################
                ## store the results
                global.results$data$output <- res.comb
            }

            ##################################
            ## moderated F test
            if(test == 'mod F'){
                cat('test F...')
                withProgress(message='moderated F-test', value=0, {

                        res.comb <- modF.test( tab, id.col=id.col, class.vector=groups, nastrings=NASTRINGS, na.rm=FALSE)$output
                        colnames(res.comb) <- sub('^X', '', colnames(res.comb))
                })
                ##################################
                ## reorder table
                res.id <- res.comb$id ## id column
                ##res.exprs <- res.comb[, names(groups)] ## expression values
                res.exprs <- tab[, names(groups)]
                res.test <- res.comb[, grep('^logFC|^AveExpr|^F$|^P\\.Value$|^adj.P.Val$|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                res.test <- res.test[, order(colnames(res.test))]

                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                ##res.comb <- res.comb[tab[, id.col], ]
                res.comb <- res.comb[rownames(tab),]
                ###########################################
                ## store the results
                 global.results$data$output <- res.comb
            }

            ###################################################################
            ##
            ##                       no test
            ##
            ###################################################################
            if(test == 'none'){
                ###########################################
                ## store data matrix as test results
                ## - values are log
                res.comb <- tab
                ###########################################
                ## store the results
                global.results$data$output <- res.comb

            }

            #######################################
            ## set some flags
            global.param$analysis.run <- T
            global.results$export.results <- F

            ###################################################################
            ##            insert the panels for the volcanos
            ###################################################################
            if(!(global.param$which.test %in% c('mod F', 'none'))){
                ins.volc()
            }
            
           ## run.pca()
        })

        ###################################################################################
        ##                              reactive PCA
        ###################################################################################
        ##run.pca <- reactive({
        
        ##observe(global.results$filtered, {
          
    ##      cat('\n-- run.pca --\n')
          
          ##res <- filter.res()
          
    ##      global.results$pca <- my.prcomp2(global.results$filtered)
          
  ##        cat('\n-- exit: run.pca --\n')
          
    ##    })

        ###################################################################################
        ##
        ##
        ##                   filter the test results accross multiple groups
        ##
        ##
        ###################################################################################
        filter.res  <-  reactive({

           ## if(global.param$session.import.init == T) return()

            cat('\n-- filter.res --\n')
            cat('filter.type: ', global.param$filter.type, '\nfilter.value:', global.param$filter.value, '\n')

            groups.comp=unique(global.param$grp.comp)

            ## test results
            res <- data.frame(global.results$data$output)

            ##View(res)
            ##if(is.null(input$filter.type))
            global.param$filter.type=input$filter.type

            #################################
            ## top N
            if(global.param$filter.type=='top.n'){

                ######################################
                ## multiple comparisons
                if(length(groups.comp) > 1){

                    ###########################################
                    ## one/two sample tests
                    if(global.param$which.test != 'mod F'){

                        ## order according to minimal p-value
                        res <- res[ order( unlist(apply( res[, grep('^P.Value', colnames(res) )], 1, min))  ), ]
                        res <- res[ 1:input$filter.value.top.n, ]

                        ## order according to FC
                        res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]

                        ## now separate for each group comparison
                        res.groups <- lapply(groups.comp, function(g){
                            res.filt=res[ which(!is.na(paste('P.Value.', g, sep='') )), ]
                            res.filt=res.filt[ order( res.filt[, paste('P.Value.', g, sep='') ], decreasing=F) , ]
                            res.filt[1:input$filter.value.top.n, ]
                        })
                        names(res.groups) <- groups.comp

                    #########################################
                    ## F test
                    } else {

                        ## order according to
                        res <- res[order(res[, 'P.Value'], decreasing=F)[1:input$filter.value.top.n], ]

                        res.groups <- list(res)
                        names(res.groups) <- paste(groups.comp, collapse='|')
                    }

                    #################################################
                    ## one comparison only
                } else {
                     res <- res[order(res[, paste('P.Value.', groups.comp, sep='')]) , ]
                     res <- res[1:input$filter.value.top.n, ]
                     res <- res[order(res[, paste('logFC.', groups.comp, sep='')]) , ]

                     res.groups <- list(res)
                     names(res.groups) <- groups.comp
                }
                global.param$filter.value <- input$filter.value.top.n
            }
            #################################
            ## nominal p-value
            if(global.param$filter.type=='nom.p'){

                ###############################################
                ## multiple group comparisons
                if(length(groups.comp) > 1){

                    ###########################################
                    ## one/two sample tests
                    if(global.param$which.test != 'mod F'){

                        res <- res[ which( unlist(apply( res[, grep('^P.Value', colnames(res) )], 1, function(x) sum(x < input$filter.value.nom.p))) > 0), ]
                        res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]
                        ## now separate for each group comparison
                        res.groups <- lapply(groups.comp, function(g){
                            res[ which( res[, paste('P.Value.', g, sep='')] < input$filter.value.nom.p) , ]
                        })
                        names(res.groups) <- groups.comp
                    #########################################
                    ## F test
                    } else {
                        res <- res[which( res[, 'P.Value'] < input$filter.value.nom.p), ]

                        res.groups <- list(res)
                        names(res.groups) <- paste(groups.comp, collapse='|')
                    }
                ##############################################
                ## one group comparison
                } else {
                    res <- res[which(res[, paste('P.Value.', groups.comp, sep="")] < input$filter.value.nom.p), ]
                    res <-  res[order(res[, paste('logFC.', groups.comp, sep="")]), ]
                    res.groups <- list(res)
                    names(res.groups) <- groups.comp
                }
                global.param$filter.value <- input$filter.value.nom.p
            }

            #################################
            ## adjusted p-value
            if(global.param$filter.type=='adj.p'){

                ############################################################
                ## multiple group comparisons
                if(length(groups.comp) > 1){

                    ###########################################
                    ## one/two sample tests
                    if(global.param$which.test != 'mod F'){

                        res <- res[ which( unlist(apply( res[, grep('^adj.P.Val', colnames(res) )], 1, function(x) sum(as.numeric(x) < input$filter.value.adj.p ))) > 0), ]
                        res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]
                        ## now separate for each group comparison
                        res.groups <- lapply(groups.comp, function(g){
                            res[ which( res[, paste('adj.P.Val.', g, sep='')] < input$filter.value.adj.p) , ]
                        })
                        names(res.groups) <- groups.comp
                    ###########################################
                    ## F-test
                    } else {
                        res <- res[which( res[, 'adj.P.Val'] < input$filter.value.adj.p), ]

                        res.groups <- list(res)
                        names(res.groups) <- paste(groups.comp, collapse='|')
                    }
                ##############################################################
                ## one comparison
                } else {
                    res <- res[which(res[, paste('adj.P.Val.', groups.comp,sep='')] < input$filter.value.adj.p), ]
                    res <-  res[order(res[, paste('logFC.', groups.comp, sep="")]), ]
                    res.groups <- list(res)
                    names(res.groups) <- groups.comp
                }

                global.param$filter.value <- input$filter.value.adj.p
            }

            ###################################
            ## global FDR

            #################################
            ## no filter
            if(global.param$filter.type=='none'){
                global.param$filter.value <- 'none'
                res.groups <- lapply(groups.comp, function(g) res)
                names(res.groups) <- groups.comp
            }

            ###################################################
            ## global filter accross all experiments
            global.results$filtered <- res
            global.results$filtered.groups <- res.groups

        })

        ##@################################################################################
        ##
        ##                                     output
        ##
        ##@################################################################################

        #############################################################
        ##
        ##                download zip file
        ## - append timestamp to zip-file
        ##
        #############################################################


        ## download handler for zip-file
        output$download.results <- downloadHandler(

	    filename = function(){paste('results', global.param$zip.name, sep='_')},
            content = function(file){
                file.copy( paste(global.param$session.dir, global.param$zip.name, sep='/'), file)
            }, contentType = "application/zip"
        )

        #########################################
        ## download handler for experimental design template
        output$exportTemplate <- downloadHandler(
            filename = function(){ 'experimentalDesign.txt' },
            content = function(file){
                tab <- global.input$table
                exp.design <- cbind(colnames(tab), rep('', ncol(tab)))
                colnames(exp.design) <- c('Column.Name', 'Experiment')
                write.table(  exp.design, file, sep='\t', quote=F, na='', row.names=F  )
            }
        )

        ###################################################################################
        ##
        ##                    summary dataset
        ##
        ###################################################################################
        output$summary.data <- renderTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            tab <- data.frame(global.input$table.org)
            ##View(tab)
            ##cat(dim(tab), '\n')
            grp <- global.param$grp
            N.grp <- global.param$N.grp

            ##cat(nrow(tab), ' - ', length(grp), ' - ', N.grp)

            sum.tab <- t(data.frame(
                ##id=c('Rows', 'Expression columns', 'Groups'),
                N.rows=nrow(tab),
                N.columns=length(grp),
                N.groups=N.grp
            ))
            ##View(sum.tab)
            sum.tab <- data.frame(id=c('Rows', 'Expression columns', 'Groups'), sum.tab)
            colnames(sum.tab) <- c('', 'Number')
            ##rownames(sum.tab) <- c('Rows', 'Expression columns', 'Groups')

            sum.tab
        })
        #####################################################################################
        ##
        ##                summary workflow
        ##
        #####################################################################################
        output$summary.workflow <- renderTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            ## kk 20161025
            ##filter.res()


            ##cat(length(input$norm.data), '\n')
            wf.tab <- t(data.frame( global.param$log.transform, global.param$norm.data, global.param$repro.filt,  global.param$which.test,
                                   paste( global.param$filter.type, ' < ', global.param$filter.value) ))
            wf.tab <- data.frame(id=c('Log scale', 'Normalization', 'Reproduc.Filter', 'Test', 'Filter'), wf.tab)
            rownames(wf.tab) <- c('Log scale', 'Normalization', 'Reproduc.Filter', 'Test', 'Filter')


            ## special case: no filter
            if(global.param$filter.type == 'none')
                wf.tab['Filter', 2] <- 'none'
            ## special case: top N
            if(global.param$filter.type == 'top.n')
                wf.tab['Filter', 2] <- paste('top', global.param$filter.value)


            colnames(wf.tab) <- c('', '')

            wf.tab

        })
        ###################################################################################
        ##
        ##                summary test results
        ##
        ###################################################################################
        output$summary.test <- renderTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            ## extract results ## kk 20161025
            filter.res()

            res = global.results$filtered

            ## tested groups
            grp.comp=unique(global.param$grp.comp)

            ## extract filter type
            filter.type=global.param$filter.type
            filter.value=global.param$filter.value

            ######################################
            ## one/two sample mod T
            if(global.param$which.test != 'mod F'){

                if(filter.type == 'adj.p')
                    test.tab=unlist(lapply(paste('adj.P.Val', grp.comp, sep='.'), function(x) sum(res[, x] < filter.value) ))
                if(filter.type == 'nom.p')
                    test.tab=unlist(lapply(paste('P.Value', grp.comp, sep='.'), function(x) sum(res[, x] < filter.value) ))
                if(filter.type == 'top.n')
                    return(NULL)

                if(filter.type == 'none')
                    return(NULL)

                test.tab=data.frame(test.tab)

                ##rownames(test.tab) <- chopString(as.character(make.names(make.unique(grp.comp))), nChar=20)
                test.tab <- data.frame(id=chopString(as.character(make.names(make.unique(grp.comp))), nChar=20), test.tab)
                colnames(test.tab) <- c('','Number significant')
                return(test.tab)

            #######################################
            ## moderated F
            } else {
                if(filter.type == 'adj.p')
                    test.tab=data.frame(  sum(res[, 'adj.P.Val'] < filter.value) )
                if(filter.type == 'nom.p')
                    test.tab=data.frame(  sum(res[, 'P.Value'] < filter.value) )
                if(filter.type == 'top.n')
                    return(NULL)
                if(filter.type == 'none')
                    return(NULL)

                test.tab <- data.frame(test.tab)

                ##rownames(test.tab) <- chopString( paste(unique(global.param$grp), collapse=' vs. '), 20)
                test.tab <- data.frame(id=chopString( paste(unique(global.param$grp), collapse=' vs. '), 20), test.tab)
                colnames(test.tab) <- c('','Number significant')
                return(test.tab)
            }

        })
        ##@###############################################################
        ##
        ##          missing data distribution
        ##
        ##@###############################################################

        ##@################################
        ## per row
        output$summary.missing.data.row <- renderPlotly({

            if(is.null(global.results$data)) return()
            ##if(!is.null(error$msg)) return()

            tab <- data.frame(global.input$table.org)
            grp <- global.param$grp
            N.grp <- global.param$N.grp
            grp.colors.legend <- global.param$grp.colors.legend

            ## extract expression values
            dat <- tab[, -which(colnames(tab) == global.param$id.col.value)]
            dat <- data.matrix(dat)

            ## number of missing values per row
            na.row.idx <- table(apply(dat, 1, function(x) sum(is.na(x))))

            p <- plot_ly( x=names(na.row.idx)[2:length(na.row.idx)], y=na.row.idx[2:length(na.row.idx)], type='bar' )
            p <- layout(p, title=paste('Fully quantified features:', na.row.idx[1]), xaxis=list(title=paste('# missing values')), yaxis=list(title=paste('# data rows')))
            ##barplot(na.col.idx)
            p
        })
        ##@#######################################
        ## per column
        output$summary.nonmissing.data <- renderPlotly({
            if(is.null(global.results$data)) return()

            tab <- data.frame(global.input$table.org)
            grp <- global.param$grp
            N.grp <- global.param$N.grp
            grp.colors.legend <- global.param$grp.colors.legend
            grp.colors <- global.param$grp.colors

            ## extract expression values
            dat <- tab[, -which(colnames(tab) == global.param$id.col.value)]
            dat <- data.matrix(dat)

            ## order columns
            ord.idx <- order(grp)
            dat <- dat[, ord.idx]
            grp.colors <- grp.colors[ord.idx]
            grp <- grp[ord.idx]
            grp.colors.legend <- grp.colors.legend[order(names(grp.colors.legend))]
            names(grp.colors) <- colnames(dat)

            ## number of non-missing values per row
            na.col.idx <- apply(dat, 2, function(x) sum(!is.na(x)))
            ##na.col.idx <-

            ## plot
            p <- plot_ly( x=names(na.col.idx), y=na.col.idx,  color=grp, colors=grp.colors.legend, type='bar')
            p <- layout(p, title='Number of valid data points per data column', xaxis=list(title=paste('Data columns')), yaxis=list(title=paste('# data points')))



            ##################################################
            ##global.param$session.import.init <- F
            p
        })


        ##@################################################################################
        ##
        ##             display the corresponding part of the table
        ##
        ##@################################################################################
        output$tableprev <- renderDataTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            filter.res()

            tab <- global.results$filtered
            colnames(tab) <- sub('^X','',colnames(tab))
            ##rownames(tab) <- tab[, input$id.col.value]

            ## check whether there is annotation stored
            if(!is.null(global.input$table.anno))
                    tab <- cbind(tab, global.input$table.anno[ rownames(tab), ])


            if(nrow(tab) > 0){
                ## add links to uniprot
                ##up.id <- tab[, 'id']
                ##up.id <- tab[, input$id.col]
                ##up.id <- tab[, global.param$id.col.value]
                up.id <- rownames(tab)
                up.link <- paste("<a href='http://www.uniprot.org/uniprot/", sub('(_|,|;).*', '', up.id),"' target='_blank'>", up.id, "</a>", sep='')
                tab[, 'id'] <- up.link
                ##tab[, input$id.col] <- up.link
                ##tab[, global.param$id.col.value] <- up.link
                ##rownames(tab) <- up.link
            }
            tab

        }, options = list( pageLength = 50), escape=F)


        ##@################################################################################
        ##
        ##                             Volcano plot
        ##
        ##@################################################################################

        ###################################################################
        ## function to generate the panels for the volcanos
        ## insert the plots into the webpage
        ###################################################################
        ins.volc <- reactive({

            if(global.param$which.test %in% c('mod F', 'none')) return()
            ##if(!is.null(error$msg)) return()

            grp.comp <- unique( global.param$grp.comp )

            for(i in 1:length(grp.comp)){
              local({
                  my_i <- i
                  ##########################
                  ## the actual plots
                  output[[paste("volcano", grp.comp[my_i], sep='.')]] <- renderPlot({
                      plotVolcano( grp.comp[my_i], max.logP=input$max.logP )
                  })

                  ##########################
                  ## download button
                  output[[paste("downloadVolcano", grp.comp[my_i], sep='.')]] <- downloadHandler(
                      filename = paste('volcano_', global.param$filter.type, '_', global.param$filter.value, '.pdf', sep=''),
                      ##filename =  paste( 'volcano_',grp.comp[my_i],'.pdf'),
                      content = function(file){

                          pdf(file, height=11, width=11)

                          for(j in 1:length(grp.comp)){
                              local({
                                  my_j=j
                                  plotVolcano(grp.comp[my_j], max.logP=input$max.logP)
                              })
                          }
                          dev.off()
                      }
                  ) ## end download handler

                  ## ##################################
                  ## ## info table
                  ## output[[paste('info', grp.comp[my_i], sep='.')]] <-  renderTable({
                  ##     if(is.null(global.results$data)) return()
                  ##     res <- as.data.frame( global.results$data$output )
                  ##     text.tmp <- nearPoints(res, input[[paste('plot_hover', grp.comp[my_i], sep='.')]], threshold=10, maxpoints =  1, xvar=paste('logFC', grp.comp[my_i], sep='.'), yvar=paste('Log.P.Value', grp.comp[my_i], sep='.'))
                  ##     text.tmp <- text.tmp[, c('id', paste('logFC', grp.comp[my_i], sep='.'), paste('P.Value',grp.comp[my_i], sep='.'), paste('adj.P.Val', grp.comp[my_i], sep='.'))]
                  ##     rownames(text.tmp) <- NULL
                  ##     if( nrow(text.tmp) == 1 )
                  ##         text.tmp
                  ##     else{
                  ##         text.tmp[1, ] <- rep(' ', ncol(text.tmp))
                  ##         text.tmp
                  ##     }
                  ## })

                  ##################################
                  ## observe clicks
                  observeEvent(input[[paste('plot_click', grp.comp[my_i], sep='.')]], {
                      res <- as.data.frame( global.results$data$output )
                      ##group.comp <- unique(global.param$grp.comp)

                      text.tmp <- nearPoints(res, input[[paste('plot_click', grp.comp[my_i], sep='.')]], threshold=10, maxpoints =  1, xvar=paste('logFC', grp.comp[my_i], sep='.'), yvar=paste('Log.P.Value', grp.comp[my_i], sep='.'))

                      if(nrow(text.tmp) == 1){
                          ################################################
                          ## first click
                          if(is.null(volc[[ paste('x', grp.comp[my_i], sep='.')]] )){
                              volc[[paste('x', grp.comp[my_i], sep='.')]] = text.tmp[paste('logFC', grp.comp[my_i], sep='.')]
                              volc[[paste('y', grp.comp[my_i], sep='.')]] = text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]
                              volc[[paste('text', grp.comp[my_i], sep='.')]] = text.tmp['id']
                              volc[[paste('xy', grp.comp[my_i], sep='.')]] = paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')])
                              volc[[paste('P.Value', grp.comp[my_i], sep='.')]] <- text.tmp[paste('P.Value', grp.comp[my_i], sep='.')]
                              volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- text.tmp[paste('adj.P.Val', grp.comp[my_i], sep='.')]
                          } else {
                              ######################################################
                              ## REMOVE: check if point is present already
                              if( paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]) %in% volc[[paste('xy', grp.comp[my_i], sep='.')]]){

                                  ## if so remove from the list
                                  idx = which( volc[[paste('xy', grp.comp[my_i], sep='.')]] == paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]))

                                  if(length(volc[[paste('xy', grp.comp[my_i], sep='.')]] > 1)){
                                      volc[[paste('x', grp.comp[my_i], sep='.')]] <- volc[[paste('x', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('y', grp.comp[my_i], sep='.')]] <- volc[[paste('y', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('text', grp.comp[my_i], sep='.')]] <- volc[[paste('text', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('xy', grp.comp[my_i], sep='.')]] <- volc[[paste('xy', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('P.Value', grp.comp[my_i], sep='.')]] <- volc[[paste('P.Value', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]][-idx]
                                  } else {
                                      volc[[paste('text', grp.comp[my_i], sep='.')]] <- volc[[ paste('y', grp.comp[my_i], sep='.') ]] <- volc[[paste('x', grp.comp[my_i], sep='.')]] <- volc[[paste('xy', grp.comp[my_i], sep='.')]] <- volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- volc[[paste('P.Value', grp.comp[my_i], sep='.')]]<- NULL
                                                    }
                                  ################################################
                                  ## ADD: if selected point is not present add it to the list
                              } else{
                                  volc[[paste('x', grp.comp[my_i], sep='.')]]=c( volc[[paste('x', grp.comp[my_i], sep='.')]],
                                                                      text.tmp[paste('logFC', grp.comp[my_i], sep='.')])
                                  volc[[paste('y', grp.comp[my_i], sep='.')]]=c(volc[[paste('y', grp.comp[my_i], sep='.')]], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')])
                                  volc[[paste('text', grp.comp[my_i], sep='.')]]=c(volc[[paste('text', grp.comp[my_i], sep='.')]],  text.tmp[ 'id'] )
                                  volc[[paste('xy', grp.comp[my_i], sep='.')]] = c(volc[[paste('xy', grp.comp[my_i], sep='.')]], paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]) )

                                  volc[[paste('P.Value', grp.comp[my_i], sep='.')]]=c(volc[[paste('P.Value', grp.comp[my_i], sep='.')]],  text.tmp[paste('P.Value', grp.comp[my_i], sep='.')] )
                                  volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]]=c(volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]],  text.tmp[paste('adj.P.Val', grp.comp[my_i], sep='.')] )
                              }
                          }
                      }
                  }) ## end observe clicks

                  ######################################################
                  ## table of selected features
                  output[[paste('volc.tab.selected', grp.comp[my_i], sep='.')]] <- renderTable({

                      if(is.null(volc[[paste('x', grp.comp[my_i], sep='.')]])) return()
                      if(length(volc[[paste('x', grp.comp[my_i], sep='.')]]) == 0) return()

                      tags$h4('Selection:')

                      id.tmp <- volc[[paste('text', grp.comp[my_i], sep='.')]]
                      ## dat.select = data.frame(id=unlist(volc[[paste('text', grp.comp[my_i], sep='.')]]), logFC=unlist(volc[[paste('x', grp.comp[my_i], sep='.')]]), xy=unlist(volc[[paste('xy', grp.comp[my_i], sep='.')]]))
                       dat.select = data.frame(id=unlist(volc[[paste('text', grp.comp[my_i], sep='.')]]), logFC=unlist(volc[[paste('x', grp.comp[my_i], sep='.')]]), P.Value=unlist(volc[[paste('P.Value', grp.comp[my_i], sep='.')]]), adj.P.Value=unlist(volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]]) )
                      up.id <- dat.select[, 'id']
                      up.link <- paste("<a href='http://www.uniprot.org/uniprot/", sub('(_|,|;).*', '', up.id),"' target='_blank'>", up.id, "</a>", sep='')
                      dat.select[, 'id'] <- up.link

                      dat.select
                  }, sanitize.text.function = function(x) x)

              }) ## end local

            } ## end for loop

        }) ## end 'ins.volc'



        ################################################################
        ## volcano - actual plot
        ##
        ################################################################
        plotVolcano <- function(group, max.logP = 100){

            cat('\n-- plotVolcano --\n')
            if(!is.null(error$msg)) return()

            ## apply filter
            filter.res()

            ## pch for significant points
            sig.pch=23

            ## unfiltered
            res = as.data.frame( global.results$data$output )
            ##rownames(res) <- res[, input$id.col.value]
 ## filtered
            res.filt = as.data.frame(global.results$filtered.groups[[group]])
            ##rownames(res.filt) <- res.filt$id

            if(global.param$which.test != 'mod F'){
                ## extract fc and p
                logPVal <- res[, paste('Log.P.Value.', group, sep='')]
            } else {
                ## extract fc and p
                logPVal <- res[, paste('Log.P.Value',  sep='')]
            }

            logFC <- res[, paste('logFC.', group, sep='')]

            ## index of missing values
            rm.idx <- union( which(is.na(logFC)), which(is.na(logPVal)) )
            if(length(rm.idx) > 0){
                res <- res[-rm.idx, ]
                logFC <- logFC[-rm.idx]
                logPVal <- logPVal[-rm.idx]
            }

            ## which filter?
            filter.str <- paste('filter:', global.param$filter.type, '\ncutoff:', global.param$filter.value)

            ######################################################################
            ## extract significant proteins of current group/test
            ######################################################################
            ## one/two sample
            if( global.param$which.test != 'mod F'){
                if(global.param$filter.type == 'top.n'){
                    PVal <- res[, paste('P.Value.', group, sep='')]
                    sig.idx = order(PVal, decreasing=F)[1:global.param$filter.value]
                }
                if(global.param$filter.type == 'nom.p'){
                    PVal <- res[, paste('P.Value.', group, sep='')]
                    sig.idx = which(PVal <= global.param$filter.value)
                }
                if(global.param$filter.type == 'adj.p'){
                    adjPVal <- res[, paste('adj.P.Val.', group, sep='')]
                    sig.idx = which(adjPVal <= global.param$filter.value)
                }
            ######################################
            ## F-test
            } else {
                if(global.param$filter.type == 'top.n'){
                    PVal <- res[, paste('P.Value', sep='')]
                    sig.idx = order(PVal, decreasing=F)[1:global.param$filter.value]
                }
                if(global.param$filter.type == 'nom.p'){
                    PVal <- res[, paste('P.Value', sep='')]
                    sig.idx = which(PVal <= global.param$filter.value)
                }
                if(global.param$filter.type == 'adj.p'){
                    adjPVal <- res[, paste('adj.P.Val', sep='')]
                    sig.idx = which(adjPVal <= global.param$filter.value)
                }
            }
            if(global.param$filter.type == 'none')
                sig.idx = 1:length(logFC)

            ##pch.vec=rep(19, nrow(res))
            pch.vec=rep(21, nrow(res))
            cex.vec=rep( input[[paste('cex.volcano', group, sep='.')]], nrow(res))

            if(length(sig.idx) > 0){
                pch.vec[sig.idx] <- sig.pch
                cex.vec[sig.idx] <- cex.vec[1]+1


            ###################################
            ## set maximal log p value
            if(!is.null( max.logP))
                logPVal[which(logPVal > max.logP)] <- max.logP
            }
            ##cat('max.logP=',max.logP)
            #############################
            ## color gradient
            ##cat('# NA:',sum(is.na(logPVal)),'\n', sum(is.na(na.omit( logPVal))), '\n')
 ##           col=myColorRamp(c('black', 'grey20', 'darkred', 'red', 'deeppink'), na.omit(logPVal), range=c(0, max.logP))
            col=myColorRamp(c('black', 'grey20', 'darkred', 'red', 'deeppink'), na.omit(logPVal), range=c(0, max.logP), opac=1)
            col.opac=myColorRamp(c('black', 'grey20', 'darkred', 'red', 'deeppink'), na.omit(logPVal), range=c(0, max.logP), opac=0.2)
            ##col='blue'

            ## limits
            xlim = max(abs(logFC), na.rm=T)
            ##xlim <- max( abs(res), na.rm=T)
            xlim = xlim + xlim*.1
            xlim = c(-xlim, xlim)

            ## y-limits
            ylim = ifelse(is.null(max.logP), max(logPVal, na.rm=T), max.logP)
            ylim = c(0, ylim+.2*ylim)

            ####################################################
            ## plot
            par(mar=c(4,5,5,2))
            plot.new()
            plot.window( xlim=xlim, ylim=ylim, cex.axis=1.8, cex.lab=1.8)
            ## title
            mtext(group, side=3, cex=2, line=2)
            ## label axes
            ##mtext(expression(log(FC)), side=1, cex=1.8, line=3)
            if(global.param$which.test == 'Two-sample mod T')
                mtext( paste("log(", sub('.*\\.vs\\.', '', group), "/", sub('\\.vs.*', '', group),")"), side=1, cex=1.8, line=3)
            else
                mtext(expression(log(FC)), side=1, cex=1.8, line=3)

            mtext(expression(-10*log[10](P-value)), side=2, cex=1.8, line=3)
            ## draw axes
            axis(1, cex.axis=1.8)
            axis(2, las=2, cex.axis=1.8)
            ## grid
            if( input[[paste('grid.volcano', group, sep='.')]] )
                grid()
            ## actual plot
            points(logFC, logPVal, col=col, bg=col.opac, pch=pch.vec, cex=cex.vec, lwd=2)
            ##points(logFC, logPVal, col=col.noalpha, pch=pch.vec)

            ##points(logFC, logPVal, col=col)
            ## add filter
            abline(h=min(logPVal[sig.idx], na.rm=T), col='grey30', lwd=2, lty='dashed')
            text( xlim[2]-(xlim[2]*.05), min(logPVal[sig.idx], na.rm=T), paste(global.param$filter.type, global.param$filter.value, sep='='), pos=3, col='grey30')
            ## number of significant
            legend('top', bty='n', legend=paste(filter.str, '\nsig / tot: ', length(sig.idx),' / ', sum(!is.na(logFC) & !is.na(logPVal)), sep=''), cex=1.5)

            ##############################
            ## indicate directionality for two-sample tests
            if(global.param$which.test == 'Two-sample mod T'){
                legend('topleft', legend=sub('\\.vs.*', '', group), cex=2, text.col='darkblue', bty='n')
                legend('topright', legend=sub('.*\\.vs\\.', '', group), cex=2, text.col='darkblue', bty='n')
            }

            ## legend('topleft', legend=paste('\n', sum()))
            ## add selected points
            if(!is.null( volc[[paste('x', group, sep='.')]] ) & length(volc[[paste('x', group, sep='.')]]) ){
                for(i2 in 1:length(unlist(volc[[paste('x', group, sep='.')]])))
                   text(unlist(volc[[paste('x', group, sep='.')]][i2]), unlist(volc[[paste('y', group, sep='.')]][i2]), unlist(volc[[paste('text', group, sep='.')]][i2]),pos=ifelse(volc[[paste('x', group, sep='.')]][i2] < 0, 2, 4), cex=input[[paste('cex.volcano.lab', group, sep='.')]])
            }
            ##if( input[[paste('grid.volcano', group, sep='.')]] )
            ##    grid()
        }

        #######################################################################################
        ##
        ##                                profile plots
        ##
        #######################################################################################
        output$expr.profile <- renderPlot({
            if(is.null(global.results$data)) return()

            ## dataset
            if(is.null(global.results$table.log))
                tab <- data.frame(global.input$table)
            else
                tab <- data.frame(global.results$table.log)

            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            withProgress({
                   setProgress(message = 'Processing...', detail= 'Generating profile plots')
                   makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main='Before normalization')
            })

        })
        ###########################
        ## normalized
        output$expr.profile.norm <- renderPlot({
            if(is.null(global.results$data)) return()

            ## dataset
            tab <- data.frame(global.results$table.norm)

            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            withProgress({
                   setProgress(message = 'Processing...', detail= 'Generating profile plots')
                   makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main=paste(global.param$norm.data, 'normalized'))
            })

        })

        #######################################################################################
        ##
        ##                                    boxplots
        ##
        #######################################################################################

        ######################################
        ## without normalization
        output$expr.boxplot <- renderPlot({

            if(is.null(global.results$data)) return()

            ## dataset
            if(is.null(global.results$table.log))
                tab <- data.frame(global.input$table)
            else
                tab <- data.frame(global.results$table.log)

            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend
               withProgress({
                   setProgress(message = 'Processing...', detail= 'Generating Boxplots')
                   makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg)
               })
        } ##,
        ##width = function(){ width=1000},
        ##height= function(){ height=max( 30*(ncol( global.input$table)+2), 500) } )
        )
        #################################################
        ## with normalization
        output$expr.boxplot.norm <- renderPlot({

            if(is.null(global.results$data)) return()
            if(is.null(global.results$table.norm)) return()
            if(!is.null(error$msg)) return()

            ## dataset
            tab <- data.frame(global.results$table.norm)
            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg, legend=F)
        }##,
        ##width = function(){ width=1000},
        ##height= function(){ height=max( 30*(ncol( global.input$table)+2), 500) } )
        )
        ######################################################################################
        ##
        ##                                   Correlation
        ##
        ######################################################################################
        output$multi.scatter <- renderPlot({
            ##cat('tesssttt')
            if(is.null(global.results$data)) return()
            plotparams$ms.max <- input$ms.max
            plotparams$ms.max.val <- input$ms.max.val
            plotparams$ms.min.val <- input$ms.min.val

            ##cat('maxval: ', plotparams$ms.max.val,'\n')
            plotMultiScatter( define.max=plotparams$ms.max, min.val=plotparams$ms.min.val, max.val=plotparams$ms.max.val )
            ##plotMultiScatter( define.max=input$ms.max, min.val=input$ms.min.val, max.val=input$ms.max.val )
        },
        width = function(){120*(ncol(data.frame(global.input$table))-1)},
        height= function(){120*(ncol(data.frame(global.input$table))-1)}
        )

        ###############################
        ## actual plot
        plotMultiScatter <- function(define.max, min.val, max.val){

            cat('\n-- plotMultiScatter  --\n')
            ## dataset
            ##tab <- data.frame(global.input$table)
            ## dataset
            if(is.null(global.results$table.log))
                tab <- data.frame(global.input$table)
            else
                tab <- data.frame(global.results$table.log)

            ##tab <- data.frame(global.input$table)
            ##View(tab)
            ## id column
            id.col <- global.param$id.col.value
            rownames(tab) <- tab[, id.col]
            ## table
            tab <- tab[, setdiff(colnames(tab), id.col)]
            ## get groups
            grp <-  global.param$grp
            grp <- sort(grp)
            tab <- tab[, names(grp)]

            ## mapping to colors
            ##grp.col <- rep('grey10', length(grp))
            ##grp.col[which(grp == input$label.g2)] <- 'darkblue'

            colnames(tab) <- chopString(colnames(tab), STRLENGTH)

           ###############################
            ## plot
            withProgress({
                setProgress(message = 'Processing...', detail= 'Calculating correlations')
                my.multiscatter(tab, repro.filt=global.results$repro.filt, grp=grp,  grp.col.legend=global.param$grp.colors.legend, define.max=define.max, max.val=max.val, min.val=min.val)
            })
        }
        ################################
        ## download image, Multiscatter
        ##output$downloadMS <- downloadHandler(
        ##    filename =  paste( 'multiscatter.pdf'),
        ##    content = function(file){
        ##        pdf(file, height=100*ncol(global.input$table)*(11/800), width=100*ncol(global.input$table)*(11/800))
        ##        withProgress({
        ##            ##setProgress(message = 'Processing...', detail= 'Calculation correlations')
        ##            plotMultiScatter(define.max=input$ms.max, max.val=input$ms.max.val, min.val=input$ms.min.val)
        ##        })
        ##        dev.off()
        ##    }
        ##)

        #####################################################
        ## correlation matrix
        output$correlation.matrix <- renderPlot({
            if(is.null(global.results$data)) return()
             withProgress({
                 setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                 plotCorrMat(lower=input$cm.lower, upper=input$cm.upper, display_numbers=input$cm.numb)
             })
        }, width=1200, height=1000)

        #####################################################
        ## correlation matrix transposed
       ## output$correlation.matrix.trans <- renderPlot({
       ##     if(is.null(global.results$data)) return()
       ##      withProgress({
       ##          setProgress(message = 'Processing...', detail= 'Generating Heatmap')
       ##          plotCorrMat(lower=input$cm.lower, upper=input$cm.upper, trans=T, display_numbers=input$cm.numb)
       ##      })
       ## }, width=1200, height=1000)




        ###################################################
        ## correlation matrix
        ###################################################
        plotCorrMat <- function(filename=NA, lower=c('pearson', 'spearman', 'kendall', 'pcor'), upper=c('pearson', 'spearman', 'kendall', 'pcor'), trans=F, display_numbers=T){
            cat('\n-- plotCorrMat --\n')

            ## dataset
            tab <- data.frame(global.input$table)
            ## id column
            id.col <- global.param$id.col.value
            ## class vector
            grp <- sort(global.param$grp)
            grp.col.legend <- global.param$grp.colors.legend

            ## table
            tab <- tab[, setdiff(colnames(tab), id.col)]
            tab <- tab[, names(grp)]

            ## transpose
            if(trans)
                tab=t(tab)

            ###########################
            ## calculate correlations
            ## withProgress({
            ##     setProgress(message = 'Processing...', detail= 'Calculation correlations')
            cm.upper <- cor(tab, use='pairwise', method=match.arg(upper))
            cm.lower <- cor(tab, use='pairwise', method=match.arg(lower))
            ##})
            ###########################
            ## initialize correlation matrix
            cm <- matrix(NA, ncol=ncol(cm.upper),nrow=nrow(cm.upper), dimnames=dimnames(cm.upper))
            cm[ lower.tri(cm, diag=T) ] <- cm.lower[lower.tri(cm.lower, diag=T)]
            cm[ upper.tri(cm, diag=F) ] <- cm.upper[upper.tri(cm.upper, diag=F)]

            ## colors
            color.breaks = seq(-1, 1, length.out=10)
            color.hm=colorRampPalette(c('blue', 'grey80' , 'red'))(length(color.breaks))

            ## gaps between groups
            gaps.column=cumsum(table(grp))
            gaps.row=gaps.column

            ## annotation of rows/columns
            anno=data.frame(Group=grp)
            anno.color=list(Group=grp.col.legend)

            Rowv=F
            Colv=F

            ##setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))), action="prepend")
            setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))))
            if(trans)
                pheatmap(cm, fontsize_row=10, fontsize_col=10,
                     cluster_rows=Rowv, cluster_cols=Colv, border_col=NA, col=color.hm, filename=filename, labels_col=chopString(colnames(cm), STRLENGTH), labels_row=chopString(rownames(cm), STRLENGTH), main='', display_numbers=display_numbers, fontsize_number=100/ncol(cm)+10, breaks=color.breaks)
            else
                pheatmap(cm, fontsize_row=10, fontsize_col=10,
                     cluster_rows=Rowv, cluster_cols=Colv, border_col=NA, col=color.hm, filename=filename, labels_col=chopString(colnames(cm), STRLENGTH), labels_row=chopString(rownames(cm), STRLENGTH), main='', annotation_col=anno, annotation_colors=anno.color,  annotation_row=anno, display_numbers=display_numbers, fontsize_number=100/ncol(cm)+10, breaks=color.breaks, gaps_col=gaps.column, gaps_row=gaps.row)
            setHook("grid.newpage", NULL, "replace")

            ## add corr coeff
            grid.text(paste(match.arg(upper)), y=.995, x=.4, gp=gpar(fontsize=25))
            grid.text(paste(match.arg(lower)), x=-0.01, rot=90, gp=gpar(fontsize=25))
        }

        ##################################################################
        ## download correlation matrix
        ##output$downloadCM <- downloadHandler(
        ##    filename =  paste( 'corrmat_', paste(unique(c(input$cm.lower, input$cm.upper)), collapse='_'), '.pdf', sep=''),
        ##    content = function(file){
        ##        pdf(file, height=1000*(11/800), width=1200*(11/800))
        ##         withProgress({
        ##             setProgress(message = 'Processing...', detail= 'Generating Correlation Matrix')
        ##             plotCorrMat(filename=NA, lower=input$cm.lower, upper=input$cm.upper)
        ##         })
        ##        dev.off()
        ##    }
       ## )

        ####################################################################################
        ##
        ##                                  Heatmap
        ##
        ####################################################################################
        output$HM <- renderPlot({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            ######################################
            ## extract results
            filter.res()
            res = global.results$filtered

            ######################################
            ## require at least three significant hits
            ##if(nrow(res) < 3) return()
            validate(need(nrow(res) > 1, 'Need at least 2 features to draw a heatmap!'))
            
            #######################################
            ## heatmap title
            hm.title <- paste('filter:', global.param$filter.type, ' / cutoff:', global.param$filter.value, sep='')
            hm.title = paste(hm.title, '\nsig / total: ', nrow(res), ' / ', nrow( global.results$data$output ), sep='')

            #######################################
            ## extract expression values
            res = res[, names(global.param$grp)]

            ##@#####################################
            ##  dimensions depending on no. rows/columns
            ## cell width
            cw <- 40
            if(ncol(res) <  6)
                cw <- 60
            if(ncol(res) > 40)
                cw <- 20
            if(ncol(res) > 60)
                cw <- 10

            ######################################
            ## plot
            if(input$hm.max){
                withProgress({
                     setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                     ##plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, max.val=input$hm.max.val, style=global.param$which.test)
                     plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=cw, fontsize_row=input$cexRow, fontsize_col=input$cexCol, max.val=input$hm.max.val, style=global.param$which.test)
                 })
            } else {
                 withProgress({
                     setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                     ##plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, style=global.param$which.test)
                     plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=cw, fontsize_row=input$cexRow, fontsize_col=input$cexCol, style=global.param$which.test)
                 })
            }
        },
        width = function(){
            N.col=length(global.param$grp)
            if(N.col > 40) cw=25
            if(N.col > 60) cw=12
            if(N.col <= 40) cw=50
            if(N.col < 6) cw=60
            return(max(cw * N.col, 1000))
            ##max(  ifelse( length(global.param$grp)<40, 50, 25)*length(global.param$grp), 1000)
        },
        height= function(){
            ##filter.res()
            height=min( dynamicHeightHM( nrow(global.results$filtered)), 1200 )
            return(height)}
        )

        ##@################################################################################
        ## histogram of p-values
        ##@################################################################################
        output$pval.hist <- renderPlot({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            groups.comp <- unique(global.param$grp.comp)

            res = global.results$data$output

            ############################################
            ## mod T
            if(global.param$which.test != 'mod F'){
                par(mfrow=c(length(groups.comp),1))
                for(g in groups.comp){

                    pval <- res[, paste('P.Value', g, sep='.')]
                    hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=3, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                    legend('top', legend=g, cex=2)
                }
            ############################################
            ## mod F
            } else {
                pval <- res[, paste('P.Value')]
                hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=3, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                ##legend('top', legend=paste(groups), cex=2)
            }

        },
        width = function(){ width=1000},
        height= function(){ height=500*ifelse( global.param$which.test != 'mod F', length(unique(global.param$grp.comp)), 1 )} )

        ######################################################################################
        ##
        ##                                 PCA
        ##
        ######################################################################################
        output$run.pca <- renderText({
            if(is.null(global.results$data) | is.na(global.param$filter.value)) return()

            filter.res()
          
            res <- global.results$filtered
          
            validate(need(nrow(res) > 2, 'Need at least 3 features to perform PC.'))
            
            grp <- global.param$grp
            
            ## run PCA
            withProgress(message = 'PCA...',{
                    pca=my.prcomp2( res, grp )
                  })
              
            ## store results
            global.results$pca <- pca
           
            ## short summary, same as 'PCA' is generating   
            txt = paste('<p>PCA model of a mean-centered and scaled matrix of ',length(grp), ' by ', nrow(pca$loadings), '.</p>')
            txt = paste(txt, '<p>Number of PCs to cover 90% of the variance:', min(which((cumsum(pca$var)/pca$totalvar) > .9)), '.</p>')
            ##txt = paste(txt, sum())
                   
            HTML(txt)
            ##print( paste()  ) 
                   
        })
        
        
        ################################################
        ## PCA variance plots
        output$pca.var <- renderPlot({
      
          if(is.null(global.results$pca)) return()
          
          pca <- global.results$pca
          
          plotPCAvar(pca)
          
        })
        
        ################################################
        ## PCA loadings
        output$pca.loadings <- renderPlot({
           
          ##validate(need(nrow(res) > 2, 'Need at least 3 features to perform PC.'))
          if(is.null(global.results$pca)) return()
          
          pca <- global.results$pca
          
          pc1 <- as.numeric(sub('PC ','', input$pca.x))
          pc2 <- as.numeric(sub('PC ','', input$pca.y))
          pc3 <- as.numeric(sub('PC ','', input$pca.z))
          
          
          plotPCAloadings(pca, 10, pc1, pc2, pc3)
          
          
        })
        

        #####################################
        ## plot_ly: user defined components
        # output$pcaxy.plotly <- renderPlotly({
        #     if(is.null(global.results$data) | is.na(global.param$filter.value) | is.null(global.results$pca)) return()
        #     if(!is.null(error$msg)) return()
        # 
        #     pca <- global.results$pca
        #     pca.x <- as.numeric(sub('PC ','', input$pca.x))
        #     pca.y <- as.numeric(sub('PC ','', input$pca.y))
        # 
        #     pca.mat = data.frame(
        #         PC1=pca$x[, pca.x],
        #         PC2=pca$x[, pca.y]
        #     )
        #     rownames(pca.mat) <- rownames(pca$x)
        # 
        # 
        #     p <- plot_ly( x=pca.mat$PC1, y=pca.mat$PC2, type='scatter', mode='markers', marker=list(size=20, color=global.param$grp.colors), text=rownames(pca.mat) )
        #     p <- layout(p, title=paste('PC', pca.x,' vs. PC', pca.y, sep=''), xaxis=list(title=paste('PC', pca.x)), yaxis=list(title=paste('PC', pca.y)) )
        # 
        # })
        output$pcaxy.plotly <- renderPlotly({
          if(is.null(global.results$data) | is.na(global.param$filter.value) | is.null(global.results$pca)) return()
          ##if(!is.null(error$msg)) return()
          
          pca <- global.results$pca
          pca.x <- as.numeric(sub('PC ','', input$pca.x))
          pca.y <- as.numeric(sub('PC ','', input$pca.y))
          
          pca.mat = data.frame(
            PC1=pca$scores[, pca.x],
            PC2=pca$scores[, pca.y]
          )
          rownames(pca.mat) <- rownames(pca$scores)
          
          
          p <- plot_ly( x=pca.mat$PC1, y=pca.mat$PC2, type='scatter', mode='markers', marker=list(size=20, color=global.param$grp.colors), text=rownames(pca.mat) )
          p <- layout(p, title=paste('PC', pca.x,' vs. PC', pca.y, sep=''), xaxis=list(title=paste('PC', pca.x)), yaxis=list(title=paste('PC', pca.y)) )
          
        })
        
        ################################################
        ## 3d scatterplot
        output$pcaxyz.plotly <- renderPlotly({
            if(is.null(global.results$data) | is.na(global.param$filter.value) | is.null(global.results$pca)) return()
            ##if(!is.null(error$msg)) return()
          
            validate(need(length(global.param$grp) < 3, 'Cannot generate 3D plots from data with dimension < 3.'))
            
            ##if(length(global.param$grp) < 3) return()

            pca <- global.results$pca
            
            pca.x <- as.numeric(sub('PC ','', input$pca.x))
            pca.y <- as.numeric(sub('PC ','', input$pca.y))
            pca.z <- as.numeric(sub('PC ','', input$pca.z))

            pca.mat = data.frame(
                PC1=pca$scores[, pca.x],
                PC2=pca$scores[, pca.y],
                PC3=pca$scores[, pca.z]
            )
            rownames(pca.mat) <- rownames(pca$scores)

            ###########################
            ## plot
            p <- plot_ly(  x=pca.mat$PC1, y=pca.mat$PC2, z=pca.mat$PC3, type='scatter3d', mode='markers', marker=list(size=15, color=global.param$grp.colors), text=rownames(pca.mat) )
            p <- layout(p, title=paste('PC', pca.x,' vs. PC', pca.y, 'vs. PC', pca.z, sep=''), scene=list( xaxis=list(title=paste('PC', pca.x)), yaxis=list(title=paste('PC', pca.y)), zaxis=list(title=paste('PC', pca.z))) )

        })
        ####################################################
        ## PCA loadings
        output$pca.loadings <- renderPlotly({
          
          if(is.null(global.results$data) | is.na(global.param$filter.value) | is.null(global.results$pca)) return()
          if(!is.null(error$msg)) return()
          if(length(global.param$grp) < 3) return()
          
          pca <- global.results$pca
          
          pca.x <- as.numeric(sub('PC ','', input$pca.x))
          pca.y <- as.numeric(sub('PC ','', input$pca.y))
          pca.z <- as.numeric(sub('PC ','', input$pca.z))
          
        })

        ###############################################
        ## static PCA plot
        ###############################################
        plotPCA <- function(pca.x, pca.y, pca.z, plot=T){

            filter.res()
          
            res <- global.results$filtered

            ##View(res)

            ## require at least three rows
            
            validate(need(nrow(res) > 2, 'Need at least 3 features to perform PC.'))
            
            ##if(nrow(res) < 3) return()

            ## get groups
            grp <- global.param$grp

            ## require at least 2 columns (2D PCA)
            if(length(names(grp)) < 2) return()

            ## mapping to colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            ## remove missing values
            rm.idx <- apply(res, 1, function(x) sum(is.na(x)) + sum(is.infinite(x)))
            rm.idx <- which(rm.idx > 0)
            if(length(rm.idx)>0) res <- res[-rm.idx, ]
            if(nrow(res) < 3) return()

            ##View(res[, names(grp)])
            ##View(t(res[, names(grp)]))

            ## plot
            pca <- my.prcomp(t(res[, names(grp)]), col=grp.col, plot=plot, rgl=F, main='', cex.points=5, leg.vec=names(grp.col.leg), leg.col=grp.col.leg)

            return(pca)
        }



        ################################################################################################
        ## used for debugging purposes
        output$testplot <- renderPlot({

            if(is.null(global.results$data) | is.na(input$filter.value)) return()

            tab <- global.input$table

            grp <- global.param$grp
            grp <- grp[which(grp==grp[1])]


            repro.ids <- global.results$repro.filt[[unique(grp)]]

            ##tab.repro <- tab[ repro.ids, names(grp) ]

            tab <- tab[, names(grp)]


            ba <-  bland.altman.stats(as.numeric( as.character( tab[, 1 ]) ), as.numeric( as.character( tab[,  2 ] )) )

            par(mfrow=c(1,2))
            ba2 <-  bland.altman.plot(as.numeric( as.character( tab[, 1 ]) ), as.numeric( as.character( tab[,  2 ] )) )

            ##View(tab[repro.ids, ])
            ##View( global.results$table.repro.filt[repro.ids, names(grp)] )

            repro.idx2 <- union( which(ba$diffs < ba$lower.limit), which(ba$diffs > ba$upper.limit))

            mydiff <- tab[, 1] - tab[, 2]

            ##cat( tab[1:5,2], '\n', tab[1:5, 1], '\n\n', ba$diffs[1:5], '\n\n')
            ##cat(mydiff[1:5], '\n')
            ##cat('\n\n', colnames(tab)[1:2],'\n')


            repro.idx3 <- which(mydiff < ba$lower.limit | mydiff > ba$upper.limit)

            ##cat(repro.idx2)
            plot(  tab[,1], tab[, 2] )
            ##points( tab[repro.ids, 1], tab[repro.ids, 2], col='red' )
            points( tab[repro.idx2, 1], tab[repro.idx2, 2], col='blue' )
            points( tab[repro.idx3, 1], tab[repro.idx3, 2], col='green' )



        })

})


###########################################################
