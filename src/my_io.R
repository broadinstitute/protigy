## ##############################################################################
## Author:   Karsten Krug
## Purpose:  - collection of functions for reading/writing various data formats

library(pacman)

## deal with non-unique rid
parse.gctx2 <- function( fname, 
                         show_modal=FALSE, ## if TRUE and rid contains duplicates, a modal whiny window with a warning will be shown. Useful when the function is called from a shiny app.
                         ... ){
  
  p_load(magrittr)
  
  gct <- try(parse.gctx(fname, ...))
  
  if(class(gct) == 'try-error' ){
    ## - cmapR functions stop if ids are not unique
    ## - import gct using readLines and make ids unique
    if(length(grep('rid must be unique', gct) ) > 0) {
      gct.tmp <- readLines(fname)
      #first column
      rid <- gct.tmp %>% sub('\t.*','', .)
      #gct version
      ver <- rid[1]
      #data and meta data columns
      meta <- strsplit(gct.tmp[2], '\t') %>% unlist() %>% as.numeric()
      if(ver=='#1.3')
        rid.idx <- (meta[4]+3) : length(rid)
      else
        rid.idx <- 4:length(rid)
      
      #check whether ids are unique
      if(length(rid[rid.idx]) > length(unique(rid[rid.idx]))){
        warning('rids not unique! Making ids unique and exporting new GCT file...\n\n')
        
        #make unique
        #rid[rid.idx] <- make.unique(rid[rid.idx], sep='_')
        rid[rid.idx] <- de_duplicate_ids( rid[rid.idx], show_modal=show_modal)
        
        #other columns
        rest <- gct.tmp %>% sub('.*?\t','', .)
        rest[1] <- ''
        gct.tmp2 <- paste(rid, rest, sep='\t') 
        gct.tmp2[1] <-  sub('\t.*','',gct.tmp2[1])
        
        #export
        gct.unique <- sub('\\.gct', '_unique.gct', fname)
        writeLines(gct.tmp2, con=gct.unique)
        
        #import using cmapR functions
        gct <- parse.gctx(fname = gct.unique)
      }
    } #end if 'rid not unique'
  }
  
  return(gct)
}


########################################################################
## 20160504 import ssv files generated by SpecMill
## - simplified version
########################################################################
read.ssv2 <- function(file, sep.cn="|", ...){

    ssv <- read.table(file, sep=';', fill=T, row.names=NULL, stringsAsFactors=F, quote='', comment.char='', skipNul=T, ...)

    ## check whether second line is part of the header
    n=ifelse( suppressWarnings( sum(is.na(as.numeric(ssv[2, ])))) == ncol(ssv), 2, 1 )

    ## column names
    ##cnames <- sub('\\|$','',apply(ssv[1:n, ], 2, paste, collapse='|'))
    cnames <- sub('(\\|$|^\\|)','',apply(ssv[n:1, ], 2, paste, collapse='|'))
    ssv <- ssv[-c(1:n), ]

    colnames(ssv) <- cnames



    return(ssv)
}
## ####################################################
##
##  export data frames to GCT 1.2
##  
##  gct   - data frame, two first columns contain annotations, 
##          remaining column contein expression values
##  file  - character, filename
##
## #####################################################
write.gct2 <- function(gct, file='tmp.gct'){

    ## ###################################
    ## gct format
    exprs <- gct[, 3:ncol(gct)]
    gct.tmp <- c('#1.2', paste(nrow(gct), ncol(exprs), sep ='\t'))
    gct.tmp <- c(gct.tmp,
                paste(colnames(gct), collapse='\t'),
                apply(gct, 1, paste, collapse='\t')
                )
    writeLines( gct.tmp, file)
}


